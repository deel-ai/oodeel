
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../../pages/implementing_baselines_tuto/">
      
      
        <link rel="next" href="../metrics/">
      
      <link rel="icon" href="../../assets/logo.png">
      <meta name="generator" content="mkdocs-1.4.3, mkdocs-material-9.1.11">
    
    
      
        <title>OOD methods - OODEEL</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.85bb2934.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.a6bdf11c.min.css">
      
      

    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../assets/_mkdocstrings.css">
    
      <link rel="stylesheet" href="../../css/custom.css">
    
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.7/katex.min.css">
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="dark" data-md-color-accent="indigo">
  
    
    
      <script>var palette=__md_get("__palette");if(palette&&"object"==typeof palette.color)for(var key of Object.keys(palette.color))document.body.setAttribute("data-md-color-"+key,palette.color[key])</script>
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#oodeel.methods.base" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      <div data-md-color-scheme="default" data-md-component="outdated" hidden>
        
      </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="OODEEL" class="md-header__button md-logo" aria-label="OODEEL" data-md-component="logo">
      
  <img src="../../assets/logo.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            OODEEL
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              OOD methods
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
          
            
            
            
            <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="dark" data-md-color-accent="indigo"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_1">
            
              <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_2" hidden>
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 6H7c-3.31 0-6 2.69-6 6s2.69 6 6 6h10c3.31 0 6-2.69 6-6s-2.69-6-6-6zm0 10H7c-2.21 0-4-1.79-4-4s1.79-4 4-4h10c2.21 0 4 1.79 4 4s-1.79 4-4 4zM7 9c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/></svg>
              </label>
            
          
            
            
            
            <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_2">
            
              <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_1" hidden>
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 7H7a5 5 0 0 0-5 5 5 5 0 0 0 5 5h10a5 5 0 0 0 5-5 5 5 0 0 0-5-5m0 8a3 3 0 0 1-3-3 3 3 0 0 1 3-3 3 3 0 0 1 3 3 3 3 0 0 1-3 3Z"/></svg>
              </label>
            
          
        </form>
      
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/deel-ai/oodeel" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.4.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
  </div>
  <div class="md-source__repository">
    deel-ai/oodeel
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="OODEEL" class="md-nav__button md-logo" aria-label="OODEEL" data-md-component="logo">
      
  <img src="../../assets/logo.png" alt="logo">

    </a>
    OODEEL
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/deel-ai/oodeel" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.4.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
  </div>
  <div class="md-source__repository">
    deel-ai/oodeel
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        Home
      </a>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" >
      
      
      
        <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
          Tutorials
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_2">
          <span class="md-nav__icon md-icon"></span>
          Tutorials
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../pages/getting_started/" class="md-nav__link">
        Getting started: Maximum Logit Score on MNIST
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../pages/feature_extractor_tuto/" class="md-nav__link">
        Important Note On Feature Extractors
      </a>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_3" >
      
      
      
        <label class="md-nav__link" for="__nav_2_3" id="__nav_2_3_label" tabindex="0">
          OOD Baselines (Tensorflow)
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_3_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_2_3">
          <span class="md-nav__icon md-icon"></span>
          OOD Baselines (Tensorflow)
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../notebooks/tensorflow/demo_mls_msp_tf/" class="md-nav__link">
        MLS/MSP
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../notebooks/tensorflow/demo_odin_tf/" class="md-nav__link">
        ODIN
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../notebooks/tensorflow/demo_dknn_tf/" class="md-nav__link">
        DKNN
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../notebooks/tensorflow/demo_vim_tf/" class="md-nav__link">
        VIM
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../notebooks/tensorflow/demo_energy_tf/" class="md-nav__link">
        Energy
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../notebooks/tensorflow/demo_entropy_tf/" class="md-nav__link">
        Entropy
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../notebooks/tensorflow/demo_mahalanobis_tf/" class="md-nav__link">
        Mahalanobis
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../notebooks/tensorflow/demo_react_tf/" class="md-nav__link">
        React
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../notebooks/tensorflow/demo_gram_tf/" class="md-nav__link">
        Gram
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../notebooks/tensorflow/demo_gen_tf/" class="md-nav__link">
        GEN
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../notebooks/tensorflow/demo_rmds_tf/" class="md-nav__link">
        RMDS
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../notebooks/tensorflow/demo_she_tf/" class="md-nav__link">
        SHE
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../notebooks/tensorflow/demo_scale_tf/" class="md-nav__link">
        SCALE
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../notebooks/tensorflow/demo_ash_tf/" class="md-nav__link">
        ASH
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_4" >
      
      
      
        <label class="md-nav__link" for="__nav_2_4" id="__nav_2_4_label" tabindex="0">
          OOD Baselines (Torch)
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_4_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_2_4">
          <span class="md-nav__icon md-icon"></span>
          OOD Baselines (Torch)
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../notebooks/torch/demo_mls_msp_torch/" class="md-nav__link">
        MLS/MSP
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../notebooks/torch/demo_odin_torch/" class="md-nav__link">
        ODIN
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../notebooks/torch/demo_dknn_torch/" class="md-nav__link">
        DKNN
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../notebooks/torch/demo_vim_torch/" class="md-nav__link">
        VIM
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../notebooks/torch/demo_energy_torch/" class="md-nav__link">
        Energy
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../notebooks/torch/demo_entropy_torch/" class="md-nav__link">
        Entropy
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../notebooks/torch/demo_mahalanobis_torch/" class="md-nav__link">
        Mahalanobis
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../notebooks/torch/demo_react_torch/" class="md-nav__link">
        React
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../notebooks/torch/demo_gram_torch/" class="md-nav__link">
        Gram
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../notebooks/torch/demo_gen_torch/" class="md-nav__link">
        GEN
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../notebooks/torch/demo_rmds_torch/" class="md-nav__link">
        RMDS
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../notebooks/torch/demo_she_torch/" class="md-nav__link">
        SHE
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../notebooks/torch/demo_scale_torch/" class="md-nav__link">
        SCALE
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../notebooks/torch/demo_ash_torch/" class="md-nav__link">
        ASH
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_5" >
      
      
      
        <label class="md-nav__link" for="__nav_2_5" id="__nav_2_5_label" tabindex="0">
          Advanced Topics
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_5_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_2_5">
          <span class="md-nav__icon md-icon"></span>
          Advanced Topics
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../pages/datahandler_tuto/" class="md-nav__link">
        Seamlessly handling torch and tf datasets with DataHandler
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../pages/operator_tuto/" class="md-nav__link">
        Seamlessly handling torch and tf Tensors with Operator
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../pages/implementing_baselines_tuto/" class="md-nav__link">
        Implementing your own baseline
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" checked>
      
      
      
        <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
          API Reference
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="true">
        <label class="md-nav__title" for="__nav_3">
          <span class="md-nav__icon md-icon"></span>
          API Reference
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          OOD methods
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        OOD methods
      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#oodeel.methods.base" class="md-nav__link">
    oodeel.methods.base
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#oodeel.methods.base.OODBaseDetector" class="md-nav__link">
    OODBaseDetector
  </a>
  
    <nav class="md-nav" aria-label="OODBaseDetector">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.base.OODBaseDetector.requires_internal_features" class="md-nav__link">
    requires_internal_features
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.base.OODBaseDetector.requires_to_fit_dataset" class="md-nav__link">
    requires_to_fit_dataset
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.base.OODBaseDetector.__call__" class="md-nav__link">
    __call__()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.base.OODBaseDetector.fit" class="md-nav__link">
    fit()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.base.OODBaseDetector.score" class="md-nav__link">
    score()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#oodeel.methods" class="md-nav__link">
    oodeel.methods
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#oodeel.methods.DKNN" class="md-nav__link">
    DKNN
  </a>
  
    <nav class="md-nav" aria-label="DKNN">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.dknn.DKNN.requires_internal_features" class="md-nav__link">
    requires_internal_features
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.dknn.DKNN.requires_to_fit_dataset" class="md-nav__link">
    requires_to_fit_dataset
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.dknn.DKNN._fit_to_dataset" class="md-nav__link">
    _fit_to_dataset()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.dknn.DKNN._l2_normalization" class="md-nav__link">
    _l2_normalization()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.dknn.DKNN._score_tensor" class="md-nav__link">
    _score_tensor()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#oodeel.methods.Energy" class="md-nav__link">
    Energy
  </a>
  
    <nav class="md-nav" aria-label="Energy">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.energy.Energy.requires_internal_features" class="md-nav__link">
    requires_internal_features
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.energy.Energy.requires_to_fit_dataset" class="md-nav__link">
    requires_to_fit_dataset
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.energy.Energy._fit_to_dataset" class="md-nav__link">
    _fit_to_dataset()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.energy.Energy._score_tensor" class="md-nav__link">
    _score_tensor()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#oodeel.methods.Entropy" class="md-nav__link">
    Entropy
  </a>
  
    <nav class="md-nav" aria-label="Entropy">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.entropy.Entropy.requires_internal_features" class="md-nav__link">
    requires_internal_features
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.entropy.Entropy.requires_to_fit_dataset" class="md-nav__link">
    requires_to_fit_dataset
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.entropy.Entropy._fit_to_dataset" class="md-nav__link">
    _fit_to_dataset()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.entropy.Entropy._score_tensor" class="md-nav__link">
    _score_tensor()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#oodeel.methods.GEN" class="md-nav__link">
    GEN
  </a>
  
    <nav class="md-nav" aria-label="GEN">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.gen.GEN.requires_internal_features" class="md-nav__link">
    requires_internal_features
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.gen.GEN.requires_to_fit_dataset" class="md-nav__link">
    requires_to_fit_dataset
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.gen.GEN._fit_to_dataset" class="md-nav__link">
    _fit_to_dataset()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.gen.GEN._score_tensor" class="md-nav__link">
    _score_tensor()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#oodeel.methods.Gram" class="md-nav__link">
    Gram
  </a>
  
    <nav class="md-nav" aria-label="Gram">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.gram.Gram.requires_internal_features" class="md-nav__link">
    requires_internal_features
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.gram.Gram.requires_to_fit_dataset" class="md-nav__link">
    requires_to_fit_dataset
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.gram.Gram._deviation" class="md-nav__link">
    _deviation()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.gram.Gram._fit_to_dataset" class="md-nav__link">
    _fit_to_dataset()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.gram.Gram._score_tensor" class="md-nav__link">
    _score_tensor()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.gram.Gram._stat" class="md-nav__link">
    _stat()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#oodeel.methods.MLS" class="md-nav__link">
    MLS
  </a>
  
    <nav class="md-nav" aria-label="MLS">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.mls.MLS.requires_internal_features" class="md-nav__link">
    requires_internal_features
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.mls.MLS.requires_to_fit_dataset" class="md-nav__link">
    requires_to_fit_dataset
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.mls.MLS._fit_to_dataset" class="md-nav__link">
    _fit_to_dataset()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.mls.MLS._score_tensor" class="md-nav__link">
    _score_tensor()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#oodeel.methods.Mahalanobis" class="md-nav__link">
    Mahalanobis
  </a>
  
    <nav class="md-nav" aria-label="Mahalanobis">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.mahalanobis.Mahalanobis.requires_internal_features" class="md-nav__link">
    requires_internal_features
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.mahalanobis.Mahalanobis.requires_to_fit_dataset" class="md-nav__link">
    requires_to_fit_dataset
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.mahalanobis.Mahalanobis._fit_to_dataset" class="md-nav__link">
    _fit_to_dataset()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.mahalanobis.Mahalanobis._input_perturbation" class="md-nav__link">
    _input_perturbation()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.mahalanobis.Mahalanobis._mahalanobis_score" class="md-nav__link">
    _mahalanobis_score()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.mahalanobis.Mahalanobis._score_tensor" class="md-nav__link">
    _score_tensor()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#oodeel.methods.ODIN" class="md-nav__link">
    ODIN
  </a>
  
    <nav class="md-nav" aria-label="ODIN">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.odin.ODIN.requires_internal_features" class="md-nav__link">
    requires_internal_features
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.odin.ODIN.requires_to_fit_dataset" class="md-nav__link">
    requires_to_fit_dataset
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.odin.ODIN._fit_to_dataset" class="md-nav__link">
    _fit_to_dataset()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.odin.ODIN._score_tensor" class="md-nav__link">
    _score_tensor()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.odin.ODIN._temperature_loss" class="md-nav__link">
    _temperature_loss()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.odin.ODIN.input_perturbation" class="md-nav__link">
    input_perturbation()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#oodeel.methods.RMDS" class="md-nav__link">
    RMDS
  </a>
  
    <nav class="md-nav" aria-label="RMDS">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.rmds.RMDS._background_score" class="md-nav__link">
    _background_score()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.rmds.RMDS._fit_to_dataset" class="md-nav__link">
    _fit_to_dataset()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.rmds.RMDS._score_tensor" class="md-nav__link">
    _score_tensor()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#oodeel.methods.SHE" class="md-nav__link">
    SHE
  </a>
  
    <nav class="md-nav" aria-label="SHE">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.she.SHE.requires_internal_features" class="md-nav__link">
    requires_internal_features
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.she.SHE.requires_to_fit_dataset" class="md-nav__link">
    requires_to_fit_dataset
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.she.SHE._fit_to_dataset" class="md-nav__link">
    _fit_to_dataset()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.she.SHE._input_perturbation" class="md-nav__link">
    _input_perturbation()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.she.SHE._score_tensor" class="md-nav__link">
    _score_tensor()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#oodeel.methods.VIM" class="md-nav__link">
    VIM
  </a>
  
    <nav class="md-nav" aria-label="VIM">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.vim.VIM.requires_internal_features" class="md-nav__link">
    requires_internal_features
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.vim.VIM.requires_to_fit_dataset" class="md-nav__link">
    requires_to_fit_dataset
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.vim.VIM._compute_residual_score_tensor" class="md-nav__link">
    _compute_residual_score_tensor()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.vim.VIM._fit_to_dataset" class="md-nav__link">
    _fit_to_dataset()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.vim.VIM._score_tensor" class="md-nav__link">
    _score_tensor()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.vim.VIM.plot_spectrum" class="md-nav__link">
    plot_spectrum()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../metrics/" class="md-nav__link">
        Metrics
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../ooddataset/" class="md-nav__link">
        OOD dataset
      </a>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_4" >
      
      
      
        <label class="md-nav__link" for="__nav_3_4" id="__nav_3_4_label" tabindex="0">
          DataHandlers
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_4_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_3_4">
          <span class="md-nav__icon md-icon"></span>
          DataHandlers
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../tf_datahandler/" class="md-nav__link">
        TFDataHandler
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../torch_datahandler/" class="md-nav__link">
        TorchDataHandler
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_5" >
      
      
      
        <label class="md-nav__link" for="__nav_3_5" id="__nav_3_5_label" tabindex="0">
          Operators
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_5_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_3_5">
          <span class="md-nav__icon md-icon"></span>
          Operators
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../torch_operator/" class="md-nav__link">
        TorchOperator
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../tf_operator/" class="md-nav__link">
        TFOperator
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_6" >
      
      
      
        <label class="md-nav__link" for="__nav_3_6" id="__nav_3_6_label" tabindex="0">
          FeatureExtractors
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_6_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_3_6">
          <span class="md-nav__icon md-icon"></span>
          FeatureExtractors
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../keras_feature_extractor/" class="md-nav__link">
        KerasFeatureExtractor
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../torch_feature_extractor/" class="md-nav__link">
        TorchFeatureExtractor
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../training_tools/" class="md-nav__link">
        Training tools
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../utils/" class="md-nav__link">
        Utils
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../plots/" class="md-nav__link">
        Plots
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../CONTRIBUTING/" class="md-nav__link">
        Contributing
      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#oodeel.methods.base" class="md-nav__link">
    oodeel.methods.base
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#oodeel.methods.base.OODBaseDetector" class="md-nav__link">
    OODBaseDetector
  </a>
  
    <nav class="md-nav" aria-label="OODBaseDetector">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.base.OODBaseDetector.requires_internal_features" class="md-nav__link">
    requires_internal_features
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.base.OODBaseDetector.requires_to_fit_dataset" class="md-nav__link">
    requires_to_fit_dataset
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.base.OODBaseDetector.__call__" class="md-nav__link">
    __call__()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.base.OODBaseDetector.fit" class="md-nav__link">
    fit()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.base.OODBaseDetector.score" class="md-nav__link">
    score()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#oodeel.methods" class="md-nav__link">
    oodeel.methods
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#oodeel.methods.DKNN" class="md-nav__link">
    DKNN
  </a>
  
    <nav class="md-nav" aria-label="DKNN">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.dknn.DKNN.requires_internal_features" class="md-nav__link">
    requires_internal_features
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.dknn.DKNN.requires_to_fit_dataset" class="md-nav__link">
    requires_to_fit_dataset
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.dknn.DKNN._fit_to_dataset" class="md-nav__link">
    _fit_to_dataset()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.dknn.DKNN._l2_normalization" class="md-nav__link">
    _l2_normalization()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.dknn.DKNN._score_tensor" class="md-nav__link">
    _score_tensor()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#oodeel.methods.Energy" class="md-nav__link">
    Energy
  </a>
  
    <nav class="md-nav" aria-label="Energy">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.energy.Energy.requires_internal_features" class="md-nav__link">
    requires_internal_features
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.energy.Energy.requires_to_fit_dataset" class="md-nav__link">
    requires_to_fit_dataset
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.energy.Energy._fit_to_dataset" class="md-nav__link">
    _fit_to_dataset()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.energy.Energy._score_tensor" class="md-nav__link">
    _score_tensor()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#oodeel.methods.Entropy" class="md-nav__link">
    Entropy
  </a>
  
    <nav class="md-nav" aria-label="Entropy">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.entropy.Entropy.requires_internal_features" class="md-nav__link">
    requires_internal_features
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.entropy.Entropy.requires_to_fit_dataset" class="md-nav__link">
    requires_to_fit_dataset
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.entropy.Entropy._fit_to_dataset" class="md-nav__link">
    _fit_to_dataset()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.entropy.Entropy._score_tensor" class="md-nav__link">
    _score_tensor()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#oodeel.methods.GEN" class="md-nav__link">
    GEN
  </a>
  
    <nav class="md-nav" aria-label="GEN">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.gen.GEN.requires_internal_features" class="md-nav__link">
    requires_internal_features
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.gen.GEN.requires_to_fit_dataset" class="md-nav__link">
    requires_to_fit_dataset
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.gen.GEN._fit_to_dataset" class="md-nav__link">
    _fit_to_dataset()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.gen.GEN._score_tensor" class="md-nav__link">
    _score_tensor()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#oodeel.methods.Gram" class="md-nav__link">
    Gram
  </a>
  
    <nav class="md-nav" aria-label="Gram">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.gram.Gram.requires_internal_features" class="md-nav__link">
    requires_internal_features
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.gram.Gram.requires_to_fit_dataset" class="md-nav__link">
    requires_to_fit_dataset
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.gram.Gram._deviation" class="md-nav__link">
    _deviation()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.gram.Gram._fit_to_dataset" class="md-nav__link">
    _fit_to_dataset()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.gram.Gram._score_tensor" class="md-nav__link">
    _score_tensor()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.gram.Gram._stat" class="md-nav__link">
    _stat()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#oodeel.methods.MLS" class="md-nav__link">
    MLS
  </a>
  
    <nav class="md-nav" aria-label="MLS">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.mls.MLS.requires_internal_features" class="md-nav__link">
    requires_internal_features
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.mls.MLS.requires_to_fit_dataset" class="md-nav__link">
    requires_to_fit_dataset
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.mls.MLS._fit_to_dataset" class="md-nav__link">
    _fit_to_dataset()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.mls.MLS._score_tensor" class="md-nav__link">
    _score_tensor()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#oodeel.methods.Mahalanobis" class="md-nav__link">
    Mahalanobis
  </a>
  
    <nav class="md-nav" aria-label="Mahalanobis">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.mahalanobis.Mahalanobis.requires_internal_features" class="md-nav__link">
    requires_internal_features
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.mahalanobis.Mahalanobis.requires_to_fit_dataset" class="md-nav__link">
    requires_to_fit_dataset
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.mahalanobis.Mahalanobis._fit_to_dataset" class="md-nav__link">
    _fit_to_dataset()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.mahalanobis.Mahalanobis._input_perturbation" class="md-nav__link">
    _input_perturbation()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.mahalanobis.Mahalanobis._mahalanobis_score" class="md-nav__link">
    _mahalanobis_score()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.mahalanobis.Mahalanobis._score_tensor" class="md-nav__link">
    _score_tensor()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#oodeel.methods.ODIN" class="md-nav__link">
    ODIN
  </a>
  
    <nav class="md-nav" aria-label="ODIN">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.odin.ODIN.requires_internal_features" class="md-nav__link">
    requires_internal_features
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.odin.ODIN.requires_to_fit_dataset" class="md-nav__link">
    requires_to_fit_dataset
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.odin.ODIN._fit_to_dataset" class="md-nav__link">
    _fit_to_dataset()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.odin.ODIN._score_tensor" class="md-nav__link">
    _score_tensor()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.odin.ODIN._temperature_loss" class="md-nav__link">
    _temperature_loss()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.odin.ODIN.input_perturbation" class="md-nav__link">
    input_perturbation()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#oodeel.methods.RMDS" class="md-nav__link">
    RMDS
  </a>
  
    <nav class="md-nav" aria-label="RMDS">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.rmds.RMDS._background_score" class="md-nav__link">
    _background_score()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.rmds.RMDS._fit_to_dataset" class="md-nav__link">
    _fit_to_dataset()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.rmds.RMDS._score_tensor" class="md-nav__link">
    _score_tensor()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#oodeel.methods.SHE" class="md-nav__link">
    SHE
  </a>
  
    <nav class="md-nav" aria-label="SHE">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.she.SHE.requires_internal_features" class="md-nav__link">
    requires_internal_features
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.she.SHE.requires_to_fit_dataset" class="md-nav__link">
    requires_to_fit_dataset
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.she.SHE._fit_to_dataset" class="md-nav__link">
    _fit_to_dataset()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.she.SHE._input_perturbation" class="md-nav__link">
    _input_perturbation()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.she.SHE._score_tensor" class="md-nav__link">
    _score_tensor()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#oodeel.methods.VIM" class="md-nav__link">
    VIM
  </a>
  
    <nav class="md-nav" aria-label="VIM">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.vim.VIM.requires_internal_features" class="md-nav__link">
    requires_internal_features
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.vim.VIM.requires_to_fit_dataset" class="md-nav__link">
    requires_to_fit_dataset
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.vim.VIM._compute_residual_score_tensor" class="md-nav__link">
    _compute_residual_score_tensor()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.vim.VIM._fit_to_dataset" class="md-nav__link">
    _fit_to_dataset()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.vim.VIM._score_tensor" class="md-nav__link">
    _score_tensor()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#oodeel.methods.vim.VIM.plot_spectrum" class="md-nav__link">
    plot_spectrum()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
  


  <h1>OOD methods</h1>

<div class="doc doc-object doc-module">


<a id="oodeel.methods.base"></a>
  <div class="doc doc-contents first">

  

  <div class="doc doc-children">








<div class="doc doc-object doc-class">



<h2 id="oodeel.methods.base.OODBaseDetector" class="doc doc-heading">
        <code>OODBaseDetector</code>


<a href="#oodeel.methods.base.OODBaseDetector" class="headerlink" title="Permanent link">&para;</a></h2>


  <div class="doc doc-contents ">
      <p class="doc doc-class-bases">
        Bases: <code><span title="abc.ABC">ABC</span></code></p>

  
      <p>Base Class for methods that assign a score to unseen samples.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>use_react</code></td>
          <td>
                <code>bool</code>
          </td>
          <td><p>if true, apply ReAct method by clipping penultimate
activations under a threshold value.</p></td>
          <td>
                <code>False</code>
          </td>
        </tr>
        <tr>
          <td><code>react_quantile</code></td>
          <td>
                <code><span title="oodeel.types.Optional">Optional</span>[float]</code>
          </td>
          <td><p>q value in the range [0, 1] used to compute
the react clipping threshold defined as the q-th quantile penultimate layer
activations. Defaults to 0.8.</p></td>
          <td>
                <code>None</code>
          </td>
        </tr>
    </tbody>
  </table>


        <details class="quote">
          <summary>Source code in <code>oodeel/methods/base.py</code></summary>
          <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span>
<span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">OODBaseDetector</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base Class for methods that assign a score to unseen samples.</span>

<span class="sd">    Args:</span>
<span class="sd">        use_react (bool): if true, apply ReAct method by clipping penultimate</span>
<span class="sd">            activations under a threshold value.</span>
<span class="sd">        react_quantile (Optional[float]): q value in the range [0, 1] used to compute</span>
<span class="sd">            the react clipping threshold defined as the q-th quantile penultimate layer</span>
<span class="sd">            activations. Defaults to 0.8.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">use_react</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">use_scale</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">use_ash</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">react_quantile</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">scale_percentile</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">ash_percentile</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">postproc_fns</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Callable</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">feature_extractor</span><span class="p">:</span> <span class="n">FeatureExtractor</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_react</span> <span class="o">=</span> <span class="n">use_react</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_scale</span> <span class="o">=</span> <span class="n">use_scale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_ash</span> <span class="o">=</span> <span class="n">use_ash</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">react_quantile</span> <span class="o">=</span> <span class="n">react_quantile</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale_percentile</span> <span class="o">=</span> <span class="n">scale_percentile</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ash_percentile</span> <span class="o">=</span> <span class="n">ash_percentile</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">react_threshold</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">postproc_fns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_posproc_fns</span><span class="p">(</span><span class="n">postproc_fns</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">use_scale</span> <span class="ow">and</span> <span class="n">use_react</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot use both ReAct and scale at the same time&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">use_scale</span> <span class="ow">and</span> <span class="n">use_ash</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot use both ASH and scale at the same time&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">use_ash</span> <span class="ow">and</span> <span class="n">use_react</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot use both ReAct and ASH at the same time&quot;</span><span class="p">)</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">_score_tensor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">:</span> <span class="n">TensorType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Computes an OOD score for input samples &quot;inputs&quot;.</span>

<span class="sd">        Method to override with child classes.</span>

<span class="sd">        Args:</span>
<span class="sd">            inputs (TensorType): tensor to score</span>
<span class="sd">        Returns:</span>
<span class="sd">            Tuple[TensorType]: OOD scores, predicted logits</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_sanitize_posproc_fns</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">postproc_fns</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Callable</span><span class="p">],</span> <span class="kc">None</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Callable</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sanitize postproc fns used at each layer output of the feature extractor.</span>

<span class="sd">        Args:</span>
<span class="sd">            postproc_fns (Optional[List[Callable]], optional): List of postproc</span>
<span class="sd">                functions, one per output layer. Defaults to None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List[Callable]: Sanitized postproc_fns list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">postproc_fns</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">postproc_fns</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">output_layers_id</span>
            <span class="p">),</span> <span class="s2">&quot;len of postproc_fns and output_layers_id must match&quot;</span>

            <span class="k">def</span> <span class="nf">identity</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">x</span>

            <span class="n">postproc_fns</span> <span class="o">=</span> <span class="p">[</span><span class="n">identity</span> <span class="k">if</span> <span class="n">fn</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">fn</span> <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="n">postproc_fns</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">postproc_fns</span>

    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">model</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
        <span class="n">fit_dataset</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ItemType</span><span class="p">,</span> <span class="n">DatasetType</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">feature_layers_id</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[],</span>
        <span class="n">input_layer_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Prepare the detector for scoring:</span>
<span class="sd">        * Constructs the feature extractor based on the model</span>
<span class="sd">        * Calibrates the detector on ID data &quot;fit_dataset&quot; if needed,</span>
<span class="sd">            using self._fit_to_dataset</span>

<span class="sd">        Args:</span>
<span class="sd">            model: model to extract the features from</span>
<span class="sd">            fit_dataset: dataset to fit the detector on</span>
<span class="sd">            feature_layers_id (List[int]): list of str or int that identify</span>
<span class="sd">                features to output.</span>
<span class="sd">                If int, the rank of the layer in the layer list</span>
<span class="sd">                If str, the name of the layer. Defaults to [-1]</span>
<span class="sd">            input_layer_id (List[int]): = list of str or int that identify the input</span>
<span class="sd">                layer of the feature extractor.</span>
<span class="sd">                If int, the rank of the layer in the layer list</span>
<span class="sd">                If str, the name of the layer. Defaults to None.</span>
<span class="sd">            verbose (bool): if True, display a progress bar. Defaults to False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">backend</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_handler</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">FeatureExtractorClass</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="n">import_backend_specific_stuff</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>

        <span class="c1"># if required by the method, check that fit_dataset is not None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">requires_to_fit_dataset</span> <span class="ow">and</span> <span class="n">fit_dataset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;`fit_dataset` argument must be provided for this OOD detector&quot;</span>
            <span class="p">)</span>

        <span class="c1"># react: compute threshold (activation percentiles)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_react</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">fit_dataset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;if react quantile is not None, fit_dataset must be&quot;</span>
                    <span class="s2">&quot; provided to compute react activation threshold&quot;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">compute_react_threshold</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">fit_dataset</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">feature_layers_id</span> <span class="o">==</span> <span class="p">[])</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">requires_internal_features</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Explicitly specify feature_layers_id=[layer0, layer1,...], &quot;</span>
                <span class="o">+</span> <span class="s2">&quot;where layer0, layer1,... are the names of the desired output &quot;</span>
                <span class="o">+</span> <span class="s2">&quot;layers of your model. These can be int or str (even though str&quot;</span>
                <span class="o">+</span> <span class="s2">&quot; is safer). To know what to put, have a look at model.summary() &quot;</span>
                <span class="o">+</span> <span class="s2">&quot;with keras or model.named_modules() with pytorch&quot;</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">feature_extractor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_feature_extractor</span><span class="p">(</span>
            <span class="n">model</span><span class="p">,</span> <span class="n">feature_layers_id</span><span class="p">,</span> <span class="n">input_layer_id</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">fit_dataset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;verbose&quot;</span> <span class="ow">in</span> <span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fit_to_dataset</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;verbose&quot;</span><span class="p">:</span> <span class="n">verbose</span><span class="p">})</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fit_to_dataset</span><span class="p">(</span><span class="n">fit_dataset</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_load_feature_extractor</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">model</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
        <span class="n">feature_layers_id</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">input_layer_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loads feature extractor</span>

<span class="sd">        Args:</span>
<span class="sd">            model: a model (Keras or PyTorch) to load.</span>
<span class="sd">            feature_layers_id (List[int]): list of str or int that identify</span>
<span class="sd">                features to output.</span>
<span class="sd">                If int, the rank of the layer in the layer list</span>
<span class="sd">                If str, the name of the layer. Defaults to [-1]</span>
<span class="sd">            input_layer_id (List[int]): = list of str or int that identify the input</span>
<span class="sd">                layer of the feature extractor.</span>
<span class="sd">                If int, the rank of the layer in the layer list</span>
<span class="sd">                If str, the name of the layer. Defaults to None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            FeatureExtractor: a feature extractor instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_ash</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ash_percentile</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_scale</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scale_percentile</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">feature_extractor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">FeatureExtractorClass</span><span class="p">(</span>
            <span class="n">model</span><span class="p">,</span>
            <span class="n">feature_layers_id</span><span class="o">=</span><span class="n">feature_layers_id</span><span class="p">,</span>
            <span class="n">input_layer_id</span><span class="o">=</span><span class="n">input_layer_id</span><span class="p">,</span>
            <span class="n">react_threshold</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">react_threshold</span><span class="p">,</span>
            <span class="n">scale_percentile</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scale_percentile</span><span class="p">,</span>
            <span class="n">ash_percentile</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ash_percentile</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">feature_extractor</span>

    <span class="k">def</span> <span class="nf">_fit_to_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fit_dataset</span><span class="p">:</span> <span class="n">DatasetType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fits the OOD detector to fit_dataset.</span>

<span class="sd">        To be overrided in child classes (if needed)</span>

<span class="sd">        Args:</span>
<span class="sd">            fit_dataset: dataset to fit the OOD detector on</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">score</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dataset</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ItemType</span><span class="p">,</span> <span class="n">DatasetType</span><span class="p">],</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes an OOD score for input samples &quot;inputs&quot;.</span>

<span class="sd">        Args:</span>
<span class="sd">            dataset (Union[ItemType, DatasetType]): dataset or tensors to score</span>
<span class="sd">            verbose (bool): if True, display a progress bar. Defaults to False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple: scores or list of scores (depending on the input) and a dictionary</span>
<span class="sd">                containing logits and labels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_extractor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Call .fit() before .score()&quot;</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Case 1: dataset is neither a tf.data.Dataset nor a torch.DataLoader</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">get_args</span><span class="p">(</span><span class="n">ItemType</span><span class="p">)):</span>
            <span class="n">tensor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_handler</span><span class="o">.</span><span class="n">get_input_from_dataset_item</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
            <span class="n">scores</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_score_tensor</span><span class="p">(</span><span class="n">tensor</span><span class="p">)</span>
            <span class="n">logits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">convert_to_numpy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">feature_extractor</span><span class="o">.</span><span class="n">_last_logits</span><span class="p">)</span>

            <span class="c1"># Get labels if dataset is a tuple/list</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
                <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_handler</span><span class="o">.</span><span class="n">get_label_from_dataset_item</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
                <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">convert_to_numpy</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>

        <span class="c1"># Case 2: dataset is a tf.data.Dataset or a torch.DataLoader</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">get_args</span><span class="p">(</span><span class="n">DatasetType</span><span class="p">)):</span>
            <span class="n">scores</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
            <span class="n">logits</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Scoring&quot;</span><span class="p">,</span> <span class="n">disable</span><span class="o">=</span><span class="ow">not</span> <span class="n">verbose</span><span class="p">):</span>
                <span class="n">tensor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_handler</span><span class="o">.</span><span class="n">get_input_from_dataset_item</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
                <span class="n">score_batch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_score_tensor</span><span class="p">(</span><span class="n">tensor</span><span class="p">)</span>
                <span class="n">logits_batch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">convert_to_numpy</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">feature_extractor</span><span class="o">.</span><span class="n">_last_logits</span>
                <span class="p">)</span>

                <span class="c1"># get the label if available</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">labels_batch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_handler</span><span class="o">.</span><span class="n">get_label_from_dataset_item</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
                    <span class="n">labels</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">labels_batch</span>
                        <span class="k">if</span> <span class="n">labels</span> <span class="ow">is</span> <span class="kc">None</span>
                        <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">convert_to_numpy</span><span class="p">(</span><span class="n">labels_batch</span><span class="p">))</span>
                    <span class="p">)</span>

                <span class="n">scores</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">scores</span><span class="p">,</span> <span class="n">score_batch</span><span class="p">)</span>
                <span class="n">logits</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">logits_batch</span>
                    <span class="k">if</span> <span class="n">logits</span> <span class="ow">is</span> <span class="kc">None</span>
                    <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">logits</span><span class="p">,</span> <span class="n">logits_batch</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;OODBaseDetector.score() not implemented for </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="n">info</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="n">labels</span><span class="p">,</span> <span class="n">logits</span><span class="o">=</span><span class="n">logits</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">scores</span><span class="p">,</span> <span class="n">info</span>

    <span class="k">def</span> <span class="nf">compute_react_threshold</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">fit_dataset</span><span class="p">:</span> <span class="n">DatasetType</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">):</span>
        <span class="n">penult_feat_extractor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_feature_extractor</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">unclipped_features</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">penult_feat_extractor</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span>
            <span class="n">fit_dataset</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">react_threshold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span>
            <span class="n">unclipped_features</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">react_quantile</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ItemType</span><span class="p">,</span> <span class="n">DatasetType</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convenience wrapper for score</span>

<span class="sd">        Args:</span>
<span class="sd">            inputs (Union[ItemType, DatasetType]): dataset or tensors to score.</span>
<span class="sd">            threshold (float): threshold to use for distinguishing between OOD and ID</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: array of 0 for ID samples and 1 for OOD samples</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">requires_to_fit_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Whether an OOD detector needs a `fit_dataset` argument in the fit function.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if `fit_dataset` is required else False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;Property `requires_to_fit_dataset` is not implemented. It should return&quot;</span>
            <span class="o">+</span> <span class="s2">&quot; a True or False boolean.&quot;</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">requires_internal_features</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Whether an OOD detector acts on internal model features.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if the detector perform computations on an intermediate layer</span>
<span class="sd">            else False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;Property `requires_internal_dataset` is not implemented. It should return&quot;</span>
            <span class="o">+</span> <span class="s2">&quot; a True or False boolean.&quot;</span>
        <span class="p">)</span>
</code></pre></div></td></tr></table></div>
        </details>

  

  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h3 id="oodeel.methods.base.OODBaseDetector.requires_internal_features" class="doc doc-heading">
<code class="highlight language-python"><span class="n">requires_internal_features</span><span class="p">:</span> <span class="nb">bool</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

<a href="#oodeel.methods.base.OODBaseDetector.requires_internal_features" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Whether an OOD detector acts on internal model features.</p>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>bool</code></td>          <td>
                <code>bool</code>
          </td>
          <td><p>True if the detector perform computations on an intermediate layer</p></td>
        </tr>
        <tr>
<td></td>          <td>
                <code>bool</code>
          </td>
          <td><p>else False.</p></td>
        </tr>
    </tbody>
  </table>
  </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="oodeel.methods.base.OODBaseDetector.requires_to_fit_dataset" class="doc doc-heading">
<code class="highlight language-python"><span class="n">requires_to_fit_dataset</span><span class="p">:</span> <span class="nb">bool</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

<a href="#oodeel.methods.base.OODBaseDetector.requires_to_fit_dataset" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Whether an OOD detector needs a <code>fit_dataset</code> argument in the fit function.</p>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>bool</code></td>          <td>
                <code>bool</code>
          </td>
          <td><p>True if <code>fit_dataset</code> is required else False.</p></td>
        </tr>
    </tbody>
  </table>
  </div>

</div>



<div class="doc doc-object doc-function">



<h3 id="oodeel.methods.base.OODBaseDetector.__call__" class="doc doc-heading">
<code class="highlight language-python"><span class="fm">__call__</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span></code>

<a href="#oodeel.methods.base.OODBaseDetector.__call__" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Convenience wrapper for score</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>inputs</code></td>
          <td>
                <code><span title="oodeel.types.Union">Union</span>[<span title="oodeel.types.ItemType">ItemType</span>, <span title="oodeel.types.DatasetType">DatasetType</span>]</code>
          </td>
          <td><p>dataset or tensors to score.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>threshold</code></td>
          <td>
                <code>float</code>
          </td>
          <td><p>threshold to use for distinguishing between OOD and ID</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>np.ndarray: array of 0 for ID samples and 1 for OOD samples</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>oodeel/methods/base.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span>
<span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ItemType</span><span class="p">,</span> <span class="n">DatasetType</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convenience wrapper for score</span>

<span class="sd">    Args:</span>
<span class="sd">        inputs (Union[ItemType, DatasetType]): dataset or tensors to score.</span>
<span class="sd">        threshold (float): threshold to use for distinguishing between OOD and ID</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: array of 0 for ID samples and 1 for OOD samples</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h3 id="oodeel.methods.base.OODBaseDetector.fit" class="doc doc-heading">
<code class="highlight language-python"><span class="n">fit</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">fit_dataset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">feature_layers_id</span><span class="o">=</span><span class="p">[],</span> <span class="n">input_layer_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

<a href="#oodeel.methods.base.OODBaseDetector.fit" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Prepare the detector for scoring:
* Constructs the feature extractor based on the model
* Calibrates the detector on ID data "fit_dataset" if needed,
    using self._fit_to_dataset</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>model</code></td>
          <td>
                <code><span title="oodeel.types.Callable">Callable</span></code>
          </td>
          <td><p>model to extract the features from</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>fit_dataset</code></td>
          <td>
                <code><span title="oodeel.types.Optional">Optional</span>[<span title="oodeel.types.Union">Union</span>[<span title="oodeel.types.ItemType">ItemType</span>, <span title="oodeel.types.DatasetType">DatasetType</span>]]</code>
          </td>
          <td><p>dataset to fit the detector on</p></td>
          <td>
                <code>None</code>
          </td>
        </tr>
        <tr>
          <td><code>feature_layers_id</code></td>
          <td>
                <code><span title="oodeel.types.List">List</span>[int]</code>
          </td>
          <td><p>list of str or int that identify
features to output.
If int, the rank of the layer in the layer list
If str, the name of the layer. Defaults to [-1]</p></td>
          <td>
                <code>[]</code>
          </td>
        </tr>
        <tr>
          <td><code>input_layer_id</code></td>
          <td>
                <code><span title="oodeel.types.List">List</span>[int]</code>
          </td>
          <td><p>= list of str or int that identify the input
layer of the feature extractor.
If int, the rank of the layer in the layer list
If str, the name of the layer. Defaults to None.</p></td>
          <td>
                <code>None</code>
          </td>
        </tr>
        <tr>
          <td><code>verbose</code></td>
          <td>
                <code>bool</code>
          </td>
          <td><p>if True, display a progress bar. Defaults to False.</p></td>
          <td>
                <code>False</code>
          </td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>oodeel/methods/base.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">fit</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">model</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
    <span class="n">fit_dataset</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ItemType</span><span class="p">,</span> <span class="n">DatasetType</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">feature_layers_id</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[],</span>
    <span class="n">input_layer_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Prepare the detector for scoring:</span>
<span class="sd">    * Constructs the feature extractor based on the model</span>
<span class="sd">    * Calibrates the detector on ID data &quot;fit_dataset&quot; if needed,</span>
<span class="sd">        using self._fit_to_dataset</span>

<span class="sd">    Args:</span>
<span class="sd">        model: model to extract the features from</span>
<span class="sd">        fit_dataset: dataset to fit the detector on</span>
<span class="sd">        feature_layers_id (List[int]): list of str or int that identify</span>
<span class="sd">            features to output.</span>
<span class="sd">            If int, the rank of the layer in the layer list</span>
<span class="sd">            If str, the name of the layer. Defaults to [-1]</span>
<span class="sd">        input_layer_id (List[int]): = list of str or int that identify the input</span>
<span class="sd">            layer of the feature extractor.</span>
<span class="sd">            If int, the rank of the layer in the layer list</span>
<span class="sd">            If str, the name of the layer. Defaults to None.</span>
<span class="sd">        verbose (bool): if True, display a progress bar. Defaults to False.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">backend</span><span class="p">,</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_handler</span><span class="p">,</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="p">,</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">FeatureExtractorClass</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">=</span> <span class="n">import_backend_specific_stuff</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>

    <span class="c1"># if required by the method, check that fit_dataset is not None</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">requires_to_fit_dataset</span> <span class="ow">and</span> <span class="n">fit_dataset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;`fit_dataset` argument must be provided for this OOD detector&quot;</span>
        <span class="p">)</span>

    <span class="c1"># react: compute threshold (activation percentiles)</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_react</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">fit_dataset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;if react quantile is not None, fit_dataset must be&quot;</span>
                <span class="s2">&quot; provided to compute react activation threshold&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_react_threshold</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">fit_dataset</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">feature_layers_id</span> <span class="o">==</span> <span class="p">[])</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">requires_internal_features</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Explicitly specify feature_layers_id=[layer0, layer1,...], &quot;</span>
            <span class="o">+</span> <span class="s2">&quot;where layer0, layer1,... are the names of the desired output &quot;</span>
            <span class="o">+</span> <span class="s2">&quot;layers of your model. These can be int or str (even though str&quot;</span>
            <span class="o">+</span> <span class="s2">&quot; is safer). To know what to put, have a look at model.summary() &quot;</span>
            <span class="o">+</span> <span class="s2">&quot;with keras or model.named_modules() with pytorch&quot;</span>
        <span class="p">)</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">feature_extractor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_feature_extractor</span><span class="p">(</span>
        <span class="n">model</span><span class="p">,</span> <span class="n">feature_layers_id</span><span class="p">,</span> <span class="n">input_layer_id</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">fit_dataset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="s2">&quot;verbose&quot;</span> <span class="ow">in</span> <span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fit_to_dataset</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;verbose&quot;</span><span class="p">:</span> <span class="n">verbose</span><span class="p">})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fit_to_dataset</span><span class="p">(</span><span class="n">fit_dataset</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h3 id="oodeel.methods.base.OODBaseDetector.score" class="doc doc-heading">
<code class="highlight language-python"><span class="n">score</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

<a href="#oodeel.methods.base.OODBaseDetector.score" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Computes an OOD score for input samples "inputs".</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>dataset</code></td>
          <td>
                <code><span title="oodeel.types.Union">Union</span>[<span title="oodeel.types.ItemType">ItemType</span>, <span title="oodeel.types.DatasetType">DatasetType</span>]</code>
          </td>
          <td><p>dataset or tensors to score</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>verbose</code></td>
          <td>
                <code>bool</code>
          </td>
          <td><p>if True, display a progress bar. Defaults to False.</p></td>
          <td>
                <code>False</code>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>tuple</code></td>          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>scores or list of scores (depending on the input) and a dictionary
containing logits and labels.</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>oodeel/methods/base.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">score</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">dataset</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ItemType</span><span class="p">,</span> <span class="n">DatasetType</span><span class="p">],</span>
    <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes an OOD score for input samples &quot;inputs&quot;.</span>

<span class="sd">    Args:</span>
<span class="sd">        dataset (Union[ItemType, DatasetType]): dataset or tensors to score</span>
<span class="sd">        verbose (bool): if True, display a progress bar. Defaults to False.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: scores or list of scores (depending on the input) and a dictionary</span>
<span class="sd">            containing logits and labels.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_extractor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Call .fit() before .score()&quot;</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="c1"># Case 1: dataset is neither a tf.data.Dataset nor a torch.DataLoader</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">get_args</span><span class="p">(</span><span class="n">ItemType</span><span class="p">)):</span>
        <span class="n">tensor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_handler</span><span class="o">.</span><span class="n">get_input_from_dataset_item</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
        <span class="n">scores</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_score_tensor</span><span class="p">(</span><span class="n">tensor</span><span class="p">)</span>
        <span class="n">logits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">convert_to_numpy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">feature_extractor</span><span class="o">.</span><span class="n">_last_logits</span><span class="p">)</span>

        <span class="c1"># Get labels if dataset is a tuple/list</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_handler</span><span class="o">.</span><span class="n">get_label_from_dataset_item</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">convert_to_numpy</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>

    <span class="c1"># Case 2: dataset is a tf.data.Dataset or a torch.DataLoader</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">get_args</span><span class="p">(</span><span class="n">DatasetType</span><span class="p">)):</span>
        <span class="n">scores</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="n">logits</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Scoring&quot;</span><span class="p">,</span> <span class="n">disable</span><span class="o">=</span><span class="ow">not</span> <span class="n">verbose</span><span class="p">):</span>
            <span class="n">tensor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_handler</span><span class="o">.</span><span class="n">get_input_from_dataset_item</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
            <span class="n">score_batch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_score_tensor</span><span class="p">(</span><span class="n">tensor</span><span class="p">)</span>
            <span class="n">logits_batch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">convert_to_numpy</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">feature_extractor</span><span class="o">.</span><span class="n">_last_logits</span>
            <span class="p">)</span>

            <span class="c1"># get the label if available</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">labels_batch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_handler</span><span class="o">.</span><span class="n">get_label_from_dataset_item</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
                <span class="n">labels</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">labels_batch</span>
                    <span class="k">if</span> <span class="n">labels</span> <span class="ow">is</span> <span class="kc">None</span>
                    <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">convert_to_numpy</span><span class="p">(</span><span class="n">labels_batch</span><span class="p">))</span>
                <span class="p">)</span>

            <span class="n">scores</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">scores</span><span class="p">,</span> <span class="n">score_batch</span><span class="p">)</span>
            <span class="n">logits</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">logits_batch</span>
                <span class="k">if</span> <span class="n">logits</span> <span class="ow">is</span> <span class="kc">None</span>
                <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">logits</span><span class="p">,</span> <span class="n">logits_batch</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;OODBaseDetector.score() not implemented for </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="n">info</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="n">labels</span><span class="p">,</span> <span class="n">logits</span><span class="o">=</span><span class="n">logits</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">scores</span><span class="p">,</span> <span class="n">info</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>



  </div>

  </div>

</div>




  </div>

  </div>

</div>

<div class="doc doc-object doc-module">


<a id="oodeel.methods"></a>
  <div class="doc doc-contents first">

  

  <div class="doc doc-children">








<div class="doc doc-object doc-class">



<h2 id="oodeel.methods.DKNN" class="doc doc-heading">
        <code>DKNN</code>


<a href="#oodeel.methods.DKNN" class="headerlink" title="Permanent link">&para;</a></h2>


  <div class="doc doc-contents ">
      <p class="doc doc-class-bases">
        Bases: <code><a class="autorefs autorefs-internal" title="oodeel.methods.base.OODBaseDetector" href="#oodeel.methods.base.OODBaseDetector">OODBaseDetector</a></code></p>

  
      <p>"Out-of-Distribution Detection with Deep Nearest Neighbors"
https://arxiv.org/abs/2204.06507</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>nearest</code></td>
          <td>
                <code>int</code>
          </td>
          <td><p>number of nearest neighbors to consider.
Defaults to 1.</p></td>
          <td>
                <code>50</code>
          </td>
        </tr>
        <tr>
          <td><code>use_gpu</code></td>
          <td>
                <code>bool</code>
          </td>
          <td><p>Flag to enable GPU acceleration for FAISS. Defaults to False.</p></td>
          <td>
                <code>False</code>
          </td>
        </tr>
    </tbody>
  </table>


        <details class="quote">
          <summary>Source code in <code>oodeel/methods/dknn.py</code></summary>
          <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 33</span>
<span class="normal"> 34</span>
<span class="normal"> 35</span>
<span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">DKNN</span><span class="p">(</span><span class="n">OODBaseDetector</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &quot;Out-of-Distribution Detection with Deep Nearest Neighbors&quot;</span>
<span class="sd">    https://arxiv.org/abs/2204.06507</span>

<span class="sd">    Args:</span>
<span class="sd">        nearest: number of nearest neighbors to consider.</span>
<span class="sd">            Defaults to 1.</span>
<span class="sd">        use_gpu (bool): Flag to enable GPU acceleration for FAISS. Defaults to False.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nearest</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span> <span class="n">use_gpu</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nearest</span> <span class="o">=</span> <span class="n">nearest</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_gpu</span> <span class="o">=</span> <span class="n">use_gpu</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_gpu</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">res</span> <span class="o">=</span> <span class="n">faiss</span><span class="o">.</span><span class="n">StandardGpuResources</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">AttributeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span>
                    <span class="s2">&quot;faiss-gpu is not installed, but use_gpu was set to True.&quot;</span>
                    <span class="o">+</span> <span class="s2">&quot;Please install faiss-gpu or set use_gpu to False.&quot;</span>
                <span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

    <span class="k">def</span> <span class="nf">_fit_to_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fit_dataset</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">TensorType</span><span class="p">,</span> <span class="n">DatasetType</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructs the index from ID data &quot;fit_dataset&quot;, which will be used for</span>
<span class="sd">        nearest neighbor search. Can operate on CPU or GPU based on the `use_gpu` flag.</span>

<span class="sd">        Args:</span>
<span class="sd">            fit_dataset: input dataset (ID) to construct the index with.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fit_projected</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_extractor</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">fit_dataset</span><span class="p">)</span>
        <span class="n">fit_projected</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">convert_to_numpy</span><span class="p">(</span><span class="n">fit_projected</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">fit_projected</span> <span class="o">=</span> <span class="n">fit_projected</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">fit_projected</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">norm_fit_projected</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_l2_normalization</span><span class="p">(</span><span class="n">fit_projected</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_gpu</span><span class="p">:</span>
            <span class="n">cpu_index</span> <span class="o">=</span> <span class="n">faiss</span><span class="o">.</span><span class="n">IndexFlatL2</span><span class="p">(</span><span class="n">norm_fit_projected</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">faiss</span><span class="o">.</span><span class="n">index_cpu_to_gpu</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">res</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cpu_index</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">faiss</span><span class="o">.</span><span class="n">IndexFlatL2</span><span class="p">(</span><span class="n">norm_fit_projected</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">norm_fit_projected</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_score_tensor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">:</span> <span class="n">TensorType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes an OOD score for input samples &quot;inputs&quot; based on</span>
<span class="sd">        the distance to nearest neighbors in the feature space of self.model</span>

<span class="sd">        Args:</span>
<span class="sd">            inputs: input samples to score</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple[np.ndarray]: scores, logits</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">input_projected</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_extractor</span><span class="o">.</span><span class="n">predict_tensor</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
        <span class="n">input_projected</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">convert_to_numpy</span><span class="p">(</span><span class="n">input_projected</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">input_projected</span> <span class="o">=</span> <span class="n">input_projected</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">input_projected</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">norm_input_projected</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_l2_normalization</span><span class="p">(</span><span class="n">input_projected</span><span class="p">)</span>
        <span class="n">scores</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">norm_input_projected</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nearest</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">scores</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_l2_normalization</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">feat</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;L2 normalization of a tensor along the last dimension.</span>

<span class="sd">        Args:</span>
<span class="sd">            feat (np.ndarray): the tensor to normalize</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: the normalized tensor</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">feat</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">feat</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1e-10</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">requires_to_fit_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Whether an OOD detector needs a `fit_dataset` argument in the fit function.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if `fit_dataset` is required else False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">requires_internal_features</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Whether an OOD detector acts on internal model features.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if the detector perform computations on an intermediate layer</span>
<span class="sd">            else False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">True</span>
</code></pre></div></td></tr></table></div>
        </details>

  

  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h3 id="oodeel.methods.dknn.DKNN.requires_internal_features" class="doc doc-heading">
<code class="highlight language-python"><span class="n">requires_internal_features</span><span class="p">:</span> <span class="nb">bool</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

<a href="#oodeel.methods.dknn.DKNN.requires_internal_features" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Whether an OOD detector acts on internal model features.</p>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>bool</code></td>          <td>
                <code>bool</code>
          </td>
          <td><p>True if the detector perform computations on an intermediate layer</p></td>
        </tr>
        <tr>
<td></td>          <td>
                <code>bool</code>
          </td>
          <td><p>else False.</p></td>
        </tr>
    </tbody>
  </table>
  </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="oodeel.methods.dknn.DKNN.requires_to_fit_dataset" class="doc doc-heading">
<code class="highlight language-python"><span class="n">requires_to_fit_dataset</span><span class="p">:</span> <span class="nb">bool</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

<a href="#oodeel.methods.dknn.DKNN.requires_to_fit_dataset" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Whether an OOD detector needs a <code>fit_dataset</code> argument in the fit function.</p>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>bool</code></td>          <td>
                <code>bool</code>
          </td>
          <td><p>True if <code>fit_dataset</code> is required else False.</p></td>
        </tr>
    </tbody>
  </table>
  </div>

</div>



<div class="doc doc-object doc-function">



<h3 id="oodeel.methods.dknn.DKNN._fit_to_dataset" class="doc doc-heading">
<code class="highlight language-python"><span class="n">_fit_to_dataset</span><span class="p">(</span><span class="n">fit_dataset</span><span class="p">)</span></code>

<a href="#oodeel.methods.dknn.DKNN._fit_to_dataset" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Constructs the index from ID data "fit_dataset", which will be used for
nearest neighbor search. Can operate on CPU or GPU based on the <code>use_gpu</code> flag.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>fit_dataset</code></td>
          <td>
                <code><span title="oodeel.types.Union">Union</span>[<span title="oodeel.types.TensorType">TensorType</span>, <span title="oodeel.types.DatasetType">DatasetType</span>]</code>
          </td>
          <td><p>input dataset (ID) to construct the index with.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>oodeel/methods/dknn.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">59</span>
<span class="normal">60</span>
<span class="normal">61</span>
<span class="normal">62</span>
<span class="normal">63</span>
<span class="normal">64</span>
<span class="normal">65</span>
<span class="normal">66</span>
<span class="normal">67</span>
<span class="normal">68</span>
<span class="normal">69</span>
<span class="normal">70</span>
<span class="normal">71</span>
<span class="normal">72</span>
<span class="normal">73</span>
<span class="normal">74</span>
<span class="normal">75</span>
<span class="normal">76</span>
<span class="normal">77</span>
<span class="normal">78</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">_fit_to_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fit_dataset</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">TensorType</span><span class="p">,</span> <span class="n">DatasetType</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Constructs the index from ID data &quot;fit_dataset&quot;, which will be used for</span>
<span class="sd">    nearest neighbor search. Can operate on CPU or GPU based on the `use_gpu` flag.</span>

<span class="sd">    Args:</span>
<span class="sd">        fit_dataset: input dataset (ID) to construct the index with.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fit_projected</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_extractor</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">fit_dataset</span><span class="p">)</span>
    <span class="n">fit_projected</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">convert_to_numpy</span><span class="p">(</span><span class="n">fit_projected</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">fit_projected</span> <span class="o">=</span> <span class="n">fit_projected</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">fit_projected</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">norm_fit_projected</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_l2_normalization</span><span class="p">(</span><span class="n">fit_projected</span><span class="p">)</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_gpu</span><span class="p">:</span>
        <span class="n">cpu_index</span> <span class="o">=</span> <span class="n">faiss</span><span class="o">.</span><span class="n">IndexFlatL2</span><span class="p">(</span><span class="n">norm_fit_projected</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">faiss</span><span class="o">.</span><span class="n">index_cpu_to_gpu</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">res</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cpu_index</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">faiss</span><span class="o">.</span><span class="n">IndexFlatL2</span><span class="p">(</span><span class="n">norm_fit_projected</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">norm_fit_projected</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h3 id="oodeel.methods.dknn.DKNN._l2_normalization" class="doc doc-heading">
<code class="highlight language-python"><span class="n">_l2_normalization</span><span class="p">(</span><span class="n">feat</span><span class="p">)</span></code>

<a href="#oodeel.methods.dknn.DKNN._l2_normalization" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>L2 normalization of a tensor along the last dimension.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>feat</code></td>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>the tensor to normalize</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>np.ndarray: the normalized tensor</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>oodeel/methods/dknn.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">_l2_normalization</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">feat</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;L2 normalization of a tensor along the last dimension.</span>

<span class="sd">    Args:</span>
<span class="sd">        feat (np.ndarray): the tensor to normalize</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: the normalized tensor</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">feat</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">feat</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1e-10</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h3 id="oodeel.methods.dknn.DKNN._score_tensor" class="doc doc-heading">
<code class="highlight language-python"><span class="n">_score_tensor</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span></code>

<a href="#oodeel.methods.dknn.DKNN._score_tensor" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Computes an OOD score for input samples "inputs" based on
the distance to nearest neighbors in the feature space of self.model</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>inputs</code></td>
          <td>
                <code><span title="oodeel.types.TensorType">TensorType</span></code>
          </td>
          <td><p>input samples to score</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code><span title="oodeel.types.Tuple">Tuple</span>[<span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span>]</code>
          </td>
          <td><p>Tuple[np.ndarray]: scores, logits</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>oodeel/methods/dknn.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">80</span>
<span class="normal">81</span>
<span class="normal">82</span>
<span class="normal">83</span>
<span class="normal">84</span>
<span class="normal">85</span>
<span class="normal">86</span>
<span class="normal">87</span>
<span class="normal">88</span>
<span class="normal">89</span>
<span class="normal">90</span>
<span class="normal">91</span>
<span class="normal">92</span>
<span class="normal">93</span>
<span class="normal">94</span>
<span class="normal">95</span>
<span class="normal">96</span>
<span class="normal">97</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">_score_tensor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">:</span> <span class="n">TensorType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes an OOD score for input samples &quot;inputs&quot; based on</span>
<span class="sd">    the distance to nearest neighbors in the feature space of self.model</span>

<span class="sd">    Args:</span>
<span class="sd">        inputs: input samples to score</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple[np.ndarray]: scores, logits</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">input_projected</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_extractor</span><span class="o">.</span><span class="n">predict_tensor</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
    <span class="n">input_projected</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">convert_to_numpy</span><span class="p">(</span><span class="n">input_projected</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">input_projected</span> <span class="o">=</span> <span class="n">input_projected</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">input_projected</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">norm_input_projected</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_l2_normalization</span><span class="p">(</span><span class="n">input_projected</span><span class="p">)</span>
    <span class="n">scores</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">norm_input_projected</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nearest</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">scores</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>



  </div>

  </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="oodeel.methods.Energy" class="doc doc-heading">
        <code>Energy</code>


<a href="#oodeel.methods.Energy" class="headerlink" title="Permanent link">&para;</a></h2>


  <div class="doc doc-contents ">
      <p class="doc doc-class-bases">
        Bases: <code><a class="autorefs autorefs-internal" title="oodeel.methods.base.OODBaseDetector" href="#oodeel.methods.base.OODBaseDetector">OODBaseDetector</a></code></p>

  
      <p>Energy Score method for OOD detection.
"Energy-based Out-of-distribution Detection"
https://arxiv.org/abs/2010.03759</p>
<p>This method assumes that the model has been trained with cross entropy loss
$CE(model(x))$ where $model(x)=(l_{c})_{c=1}^{C}$ are the logits
predicted for input $x$.
The implementation assumes that the logits are retreieved using the output with
linear activation.</p>
<p>The energy score for input $x$ is given by
$$ -\log \sum_{c=0}^C \exp(l_c)$$</p>
<p>where $model(x)=(l_{c})_{c=1}^{C}$ are the logits predicted by the model on
$x$.
As always, training data is expected to have lower score than OOD data.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>use_react</code></td>
          <td>
                <code>bool</code>
          </td>
          <td><p>if true, apply ReAct method by clipping penultimate
activations under a threshold value.</p></td>
          <td>
                <code>False</code>
          </td>
        </tr>
        <tr>
          <td><code>react_quantile</code></td>
          <td>
                <code>Optional[float]</code>
          </td>
          <td><p>q value in the range [0, 1] used to compute
the react clipping threshold defined as the q-th quantile penultimate layer
activations. Defaults to 0.8.</p></td>
          <td>
                <code>0.8</code>
          </td>
        </tr>
    </tbody>
  </table>


        <details class="quote">
          <summary>Source code in <code>oodeel/methods/energy.py</code></summary>
          <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 32</span>
<span class="normal"> 33</span>
<span class="normal"> 34</span>
<span class="normal"> 35</span>
<span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">Energy</span><span class="p">(</span><span class="n">OODBaseDetector</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Energy Score method for OOD detection.</span>
<span class="sd">    &quot;Energy-based Out-of-distribution Detection&quot;</span>
<span class="sd">    https://arxiv.org/abs/2010.03759</span>

<span class="sd">    This method assumes that the model has been trained with cross entropy loss</span>
<span class="sd">    $CE(model(x))$ where $model(x)=(l_{c})_{c=1}^{C}$ are the logits</span>
<span class="sd">    predicted for input $x$.</span>
<span class="sd">    The implementation assumes that the logits are retreieved using the output with</span>
<span class="sd">    linear activation.</span>

<span class="sd">    The energy score for input $x$ is given by</span>
<span class="sd">    $$ -\log \sum_{c=0}^C \exp(l_c)$$</span>

<span class="sd">    where $model(x)=(l_{c})_{c=1}^{C}$ are the logits predicted by the model on</span>
<span class="sd">    $x$.</span>
<span class="sd">    As always, training data is expected to have lower score than OOD data.</span>

<span class="sd">    Args:</span>
<span class="sd">        use_react (bool): if true, apply ReAct method by clipping penultimate</span>
<span class="sd">            activations under a threshold value.</span>
<span class="sd">        react_quantile (Optional[float]): q value in the range [0, 1] used to compute</span>
<span class="sd">            the react clipping threshold defined as the q-th quantile penultimate layer</span>
<span class="sd">            activations. Defaults to 0.8.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">use_react</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">use_scale</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">use_ash</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">react_quantile</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">,</span>
        <span class="n">scale_percentile</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.85</span><span class="p">,</span>
        <span class="n">ash_percentile</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.90</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">use_react</span><span class="o">=</span><span class="n">use_react</span><span class="p">,</span>
            <span class="n">use_scale</span><span class="o">=</span><span class="n">use_scale</span><span class="p">,</span>
            <span class="n">use_ash</span><span class="o">=</span><span class="n">use_ash</span><span class="p">,</span>
            <span class="n">react_quantile</span><span class="o">=</span><span class="n">react_quantile</span><span class="p">,</span>
            <span class="n">scale_percentile</span><span class="o">=</span><span class="n">scale_percentile</span><span class="p">,</span>
            <span class="n">ash_percentile</span><span class="o">=</span><span class="n">ash_percentile</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_score_tensor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">:</span> <span class="n">TensorType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes an OOD score for input samples &quot;inputs&quot; based on</span>
<span class="sd">        energy, namey $-logsumexp(logits(inputs))$.</span>

<span class="sd">        Args:</span>
<span class="sd">            inputs: input samples to score</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple[np.ndarray]: scores, logits</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># compute logits (softmax(logits,axis=1) is the actual softmax</span>
        <span class="c1"># output minimized using binary cross entropy)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">logits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_extractor</span><span class="o">.</span><span class="n">predict_tensor</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
        <span class="n">logits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">convert_to_numpy</span><span class="p">(</span><span class="n">logits</span><span class="p">)</span>
        <span class="n">scores</span> <span class="o">=</span> <span class="o">-</span><span class="n">logsumexp</span><span class="p">(</span><span class="n">logits</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">scores</span>

    <span class="k">def</span> <span class="nf">_fit_to_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fit_dataset</span><span class="p">:</span> <span class="n">DatasetType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fits the OOD detector to fit_dataset.</span>

<span class="sd">        Args:</span>
<span class="sd">            fit_dataset: dataset to fit the OOD detector on</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">requires_to_fit_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Whether an OOD detector needs a `fit_dataset` argument in the fit function.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if `fit_dataset` is required else False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">requires_internal_features</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Whether an OOD detector acts on internal model features.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if the detector perform computations on an intermediate layer</span>
<span class="sd">            else False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">False</span>
</code></pre></div></td></tr></table></div>
        </details>

  

  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h3 id="oodeel.methods.energy.Energy.requires_internal_features" class="doc doc-heading">
<code class="highlight language-python"><span class="n">requires_internal_features</span><span class="p">:</span> <span class="nb">bool</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

<a href="#oodeel.methods.energy.Energy.requires_internal_features" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Whether an OOD detector acts on internal model features.</p>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>bool</code></td>          <td>
                <code>bool</code>
          </td>
          <td><p>True if the detector perform computations on an intermediate layer</p></td>
        </tr>
        <tr>
<td></td>          <td>
                <code>bool</code>
          </td>
          <td><p>else False.</p></td>
        </tr>
    </tbody>
  </table>
  </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="oodeel.methods.energy.Energy.requires_to_fit_dataset" class="doc doc-heading">
<code class="highlight language-python"><span class="n">requires_to_fit_dataset</span><span class="p">:</span> <span class="nb">bool</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

<a href="#oodeel.methods.energy.Energy.requires_to_fit_dataset" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Whether an OOD detector needs a <code>fit_dataset</code> argument in the fit function.</p>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>bool</code></td>          <td>
                <code>bool</code>
          </td>
          <td><p>True if <code>fit_dataset</code> is required else False.</p></td>
        </tr>
    </tbody>
  </table>
  </div>

</div>



<div class="doc doc-object doc-function">



<h3 id="oodeel.methods.energy.Energy._fit_to_dataset" class="doc doc-heading">
<code class="highlight language-python"><span class="n">_fit_to_dataset</span><span class="p">(</span><span class="n">fit_dataset</span><span class="p">)</span></code>

<a href="#oodeel.methods.energy.Energy._fit_to_dataset" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Fits the OOD detector to fit_dataset.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>fit_dataset</code></td>
          <td>
                <code><span title="oodeel.types.DatasetType">DatasetType</span></code>
          </td>
          <td><p>dataset to fit the OOD detector on</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>oodeel/methods/energy.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">_fit_to_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fit_dataset</span><span class="p">:</span> <span class="n">DatasetType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fits the OOD detector to fit_dataset.</span>

<span class="sd">    Args:</span>
<span class="sd">        fit_dataset: dataset to fit the OOD detector on</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h3 id="oodeel.methods.energy.Energy._score_tensor" class="doc doc-heading">
<code class="highlight language-python"><span class="n">_score_tensor</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span></code>

<a href="#oodeel.methods.energy.Energy._score_tensor" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Computes an OOD score for input samples "inputs" based on
energy, namey $-logsumexp(logits(inputs))$.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>inputs</code></td>
          <td>
                <code><span title="oodeel.types.TensorType">TensorType</span></code>
          </td>
          <td><p>input samples to score</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code><span title="oodeel.types.Tuple">Tuple</span>[<span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span>]</code>
          </td>
          <td><p>Tuple[np.ndarray]: scores, logits</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>oodeel/methods/energy.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">77</span>
<span class="normal">78</span>
<span class="normal">79</span>
<span class="normal">80</span>
<span class="normal">81</span>
<span class="normal">82</span>
<span class="normal">83</span>
<span class="normal">84</span>
<span class="normal">85</span>
<span class="normal">86</span>
<span class="normal">87</span>
<span class="normal">88</span>
<span class="normal">89</span>
<span class="normal">90</span>
<span class="normal">91</span>
<span class="normal">92</span>
<span class="normal">93</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">_score_tensor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">:</span> <span class="n">TensorType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes an OOD score for input samples &quot;inputs&quot; based on</span>
<span class="sd">    energy, namey $-logsumexp(logits(inputs))$.</span>

<span class="sd">    Args:</span>
<span class="sd">        inputs: input samples to score</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple[np.ndarray]: scores, logits</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># compute logits (softmax(logits,axis=1) is the actual softmax</span>
    <span class="c1"># output minimized using binary cross entropy)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">logits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_extractor</span><span class="o">.</span><span class="n">predict_tensor</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
    <span class="n">logits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">convert_to_numpy</span><span class="p">(</span><span class="n">logits</span><span class="p">)</span>
    <span class="n">scores</span> <span class="o">=</span> <span class="o">-</span><span class="n">logsumexp</span><span class="p">(</span><span class="n">logits</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">scores</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>



  </div>

  </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="oodeel.methods.Entropy" class="doc doc-heading">
        <code>Entropy</code>


<a href="#oodeel.methods.Entropy" class="headerlink" title="Permanent link">&para;</a></h2>


  <div class="doc doc-contents ">
      <p class="doc doc-class-bases">
        Bases: <code><a class="autorefs autorefs-internal" title="oodeel.methods.base.OODBaseDetector" href="#oodeel.methods.base.OODBaseDetector">OODBaseDetector</a></code></p>

  
      <p>Entropy OOD score</p>
<p>The method consists in using the Entropy of the input data computed using the
Entropy $\sum_{c=0}^C p(y=c| x) \times log(p(y=c | x))$ where
$p(y=c| x) = \text{model}(x)$.</p>
<p><strong>Reference</strong>
https://proceedings.neurips.cc/paper/2019/hash/1e79596878b2320cac26dd792a6c51c9-Abstract.html,
Neurips 2019.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>use_react</code></td>
          <td>
                <code>bool</code>
          </td>
          <td><p>if true, apply ReAct method by clipping penultimate
activations under a threshold value.</p></td>
          <td>
                <code>False</code>
          </td>
        </tr>
        <tr>
          <td><code>react_quantile</code></td>
          <td>
                <code>Optional[float]</code>
          </td>
          <td><p>q value in the range [0, 1] used to compute
the react clipping threshold defined as the q-th quantile penultimate layer
activations. Defaults to 0.8.</p></td>
          <td>
                <code>0.8</code>
          </td>
        </tr>
    </tbody>
  </table>


        <details class="quote">
          <summary>Source code in <code>oodeel/methods/entropy.py</code></summary>
          <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 31</span>
<span class="normal"> 32</span>
<span class="normal"> 33</span>
<span class="normal"> 34</span>
<span class="normal"> 35</span>
<span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">Entropy</span><span class="p">(</span><span class="n">OODBaseDetector</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Entropy OOD score</span>


<span class="sd">    The method consists in using the Entropy of the input data computed using the</span>
<span class="sd">    Entropy $\sum_{c=0}^C p(y=c| x) \times log(p(y=c | x))$ where</span>
<span class="sd">    $p(y=c| x) = \text{model}(x)$.</span>

<span class="sd">    **Reference**</span>
<span class="sd">    https://proceedings.neurips.cc/paper/2019/hash/1e79596878b2320cac26dd792a6c51c9-Abstract.html,</span>
<span class="sd">    Neurips 2019.</span>

<span class="sd">    Args:</span>
<span class="sd">        use_react (bool): if true, apply ReAct method by clipping penultimate</span>
<span class="sd">            activations under a threshold value.</span>
<span class="sd">        react_quantile (Optional[float]): q value in the range [0, 1] used to compute</span>
<span class="sd">            the react clipping threshold defined as the q-th quantile penultimate layer</span>
<span class="sd">            activations. Defaults to 0.8.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">use_react</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">use_scale</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">use_ash</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">react_quantile</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">,</span>
        <span class="n">scale_percentile</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.85</span><span class="p">,</span>
        <span class="n">ash_percentile</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.90</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">use_react</span><span class="o">=</span><span class="n">use_react</span><span class="p">,</span>
            <span class="n">use_scale</span><span class="o">=</span><span class="n">use_scale</span><span class="p">,</span>
            <span class="n">use_ash</span><span class="o">=</span><span class="n">use_ash</span><span class="p">,</span>
            <span class="n">react_quantile</span><span class="o">=</span><span class="n">react_quantile</span><span class="p">,</span>
            <span class="n">scale_percentile</span><span class="o">=</span><span class="n">scale_percentile</span><span class="p">,</span>
            <span class="n">ash_percentile</span><span class="o">=</span><span class="n">ash_percentile</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_score_tensor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">:</span> <span class="n">TensorType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes an OOD score for input samples &quot;inputs&quot; based on</span>
<span class="sd">        entropy.</span>

<span class="sd">        Args:</span>
<span class="sd">            inputs: input samples to score</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple[np.ndarray]: scores, logits</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># compute logits (softmax(logits,axis=1) is the actual softmax</span>
        <span class="c1"># output minimized using binary cross entropy)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">logits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_extractor</span><span class="o">.</span><span class="n">predict_tensor</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
        <span class="n">probits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">softmax</span><span class="p">(</span><span class="n">logits</span><span class="p">)</span>
        <span class="n">probits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">convert_to_numpy</span><span class="p">(</span><span class="n">probits</span><span class="p">)</span>
        <span class="n">scores</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">probits</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">probits</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">scores</span>

    <span class="k">def</span> <span class="nf">_fit_to_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fit_dataset</span><span class="p">:</span> <span class="n">DatasetType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fits the OOD detector to fit_dataset.</span>

<span class="sd">        Args:</span>
<span class="sd">            fit_dataset: dataset to fit the OOD detector on</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">requires_to_fit_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Whether an OOD detector needs a `fit_dataset` argument in the fit function.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if `fit_dataset` is required else False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">requires_internal_features</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Whether an OOD detector acts on internal model features.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if the detector perform computations on an intermediate layer</span>
<span class="sd">            else False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">False</span>
</code></pre></div></td></tr></table></div>
        </details>

  

  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h3 id="oodeel.methods.entropy.Entropy.requires_internal_features" class="doc doc-heading">
<code class="highlight language-python"><span class="n">requires_internal_features</span><span class="p">:</span> <span class="nb">bool</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

<a href="#oodeel.methods.entropy.Entropy.requires_internal_features" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Whether an OOD detector acts on internal model features.</p>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>bool</code></td>          <td>
                <code>bool</code>
          </td>
          <td><p>True if the detector perform computations on an intermediate layer</p></td>
        </tr>
        <tr>
<td></td>          <td>
                <code>bool</code>
          </td>
          <td><p>else False.</p></td>
        </tr>
    </tbody>
  </table>
  </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="oodeel.methods.entropy.Entropy.requires_to_fit_dataset" class="doc doc-heading">
<code class="highlight language-python"><span class="n">requires_to_fit_dataset</span><span class="p">:</span> <span class="nb">bool</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

<a href="#oodeel.methods.entropy.Entropy.requires_to_fit_dataset" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Whether an OOD detector needs a <code>fit_dataset</code> argument in the fit function.</p>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>bool</code></td>          <td>
                <code>bool</code>
          </td>
          <td><p>True if <code>fit_dataset</code> is required else False.</p></td>
        </tr>
    </tbody>
  </table>
  </div>

</div>



<div class="doc doc-object doc-function">



<h3 id="oodeel.methods.entropy.Entropy._fit_to_dataset" class="doc doc-heading">
<code class="highlight language-python"><span class="n">_fit_to_dataset</span><span class="p">(</span><span class="n">fit_dataset</span><span class="p">)</span></code>

<a href="#oodeel.methods.entropy.Entropy._fit_to_dataset" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Fits the OOD detector to fit_dataset.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>fit_dataset</code></td>
          <td>
                <code><span title="oodeel.types.DatasetType">DatasetType</span></code>
          </td>
          <td><p>dataset to fit the OOD detector on</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>oodeel/methods/entropy.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">90</span>
<span class="normal">91</span>
<span class="normal">92</span>
<span class="normal">93</span>
<span class="normal">94</span>
<span class="normal">95</span>
<span class="normal">96</span>
<span class="normal">97</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">_fit_to_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fit_dataset</span><span class="p">:</span> <span class="n">DatasetType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fits the OOD detector to fit_dataset.</span>

<span class="sd">    Args:</span>
<span class="sd">        fit_dataset: dataset to fit the OOD detector on</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h3 id="oodeel.methods.entropy.Entropy._score_tensor" class="doc doc-heading">
<code class="highlight language-python"><span class="n">_score_tensor</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span></code>

<a href="#oodeel.methods.entropy.Entropy._score_tensor" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Computes an OOD score for input samples "inputs" based on
entropy.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>inputs</code></td>
          <td>
                <code><span title="oodeel.types.TensorType">TensorType</span></code>
          </td>
          <td><p>input samples to score</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code><span title="oodeel.types.Tuple">Tuple</span>[<span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span>]</code>
          </td>
          <td><p>Tuple[np.ndarray]: scores, logits</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>oodeel/methods/entropy.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">70</span>
<span class="normal">71</span>
<span class="normal">72</span>
<span class="normal">73</span>
<span class="normal">74</span>
<span class="normal">75</span>
<span class="normal">76</span>
<span class="normal">77</span>
<span class="normal">78</span>
<span class="normal">79</span>
<span class="normal">80</span>
<span class="normal">81</span>
<span class="normal">82</span>
<span class="normal">83</span>
<span class="normal">84</span>
<span class="normal">85</span>
<span class="normal">86</span>
<span class="normal">87</span>
<span class="normal">88</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">_score_tensor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">:</span> <span class="n">TensorType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes an OOD score for input samples &quot;inputs&quot; based on</span>
<span class="sd">    entropy.</span>

<span class="sd">    Args:</span>
<span class="sd">        inputs: input samples to score</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple[np.ndarray]: scores, logits</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># compute logits (softmax(logits,axis=1) is the actual softmax</span>
    <span class="c1"># output minimized using binary cross entropy)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">logits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_extractor</span><span class="o">.</span><span class="n">predict_tensor</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
    <span class="n">probits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">softmax</span><span class="p">(</span><span class="n">logits</span><span class="p">)</span>
    <span class="n">probits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">convert_to_numpy</span><span class="p">(</span><span class="n">probits</span><span class="p">)</span>
    <span class="n">scores</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">probits</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">probits</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">scores</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>



  </div>

  </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="oodeel.methods.GEN" class="doc doc-heading">
        <code>GEN</code>


<a href="#oodeel.methods.GEN" class="headerlink" title="Permanent link">&para;</a></h2>


  <div class="doc doc-contents ">
      <p class="doc doc-class-bases">
        Bases: <code><a class="autorefs autorefs-internal" title="oodeel.methods.base.OODBaseDetector" href="#oodeel.methods.base.OODBaseDetector">OODBaseDetector</a></code></p>

  
      <p>Generalized Entropy method for OOD detection.
"GEN: Pushing the Limits of Softmax-Based Out-of-Distribution Detection"
https://openaccess.thecvf.com/content/CVPR2023/html/Liu_GEN_Pushing_the_Limits_of_Softmax-Based_Out-of-Distribution_Detection_CVPR_2023_paper.html,</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>gamma</code></td>
          <td>
                <code>float</code>
          </td>
          <td><p>parameter for the generalized entropy. Must be between 0 and 1.
Defaults to 0.1.</p></td>
          <td>
                <code>0.1</code>
          </td>
        </tr>
        <tr>
          <td><code>k</code></td>
          <td>
                <code>int</code>
          </td>
          <td><p>number of softmax values to keep for the entropy computation. Only the
top-k softmax probabilities will be used. Defaults to 100.</p></td>
          <td>
                <code>100</code>
          </td>
        </tr>
        <tr>
          <td><code>use_react</code></td>
          <td>
                <code>bool</code>
          </td>
          <td><p>if true, apply ReAct method by clipping penultimate
activations under a threshold value.</p></td>
          <td>
                <code>False</code>
          </td>
        </tr>
        <tr>
          <td><code>react_quantile</code></td>
          <td>
                <code>Optional[float]</code>
          </td>
          <td><p>q value in the range [0, 1] used to compute
the react clipping threshold defined as the q-th quantile penultimate layer
activations. Defaults to 0.8.</p></td>
          <td>
                <code>0.8</code>
          </td>
        </tr>
    </tbody>
  </table>


        <details class="quote">
          <summary>Source code in <code>oodeel/methods/gen.py</code></summary>
          <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 31</span>
<span class="normal"> 32</span>
<span class="normal"> 33</span>
<span class="normal"> 34</span>
<span class="normal"> 35</span>
<span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">GEN</span><span class="p">(</span><span class="n">OODBaseDetector</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generalized Entropy method for OOD detection.</span>
<span class="sd">    &quot;GEN: Pushing the Limits of Softmax-Based Out-of-Distribution Detection&quot;</span>
<span class="sd">    https://openaccess.thecvf.com/content/CVPR2023/html/Liu_GEN_Pushing_the_Limits_of_Softmax-Based_Out-of-Distribution_Detection_CVPR_2023_paper.html,</span>

<span class="sd">    Args:</span>
<span class="sd">        gamma (float): parameter for the generalized entropy. Must be between 0 and 1.</span>
<span class="sd">            Defaults to 0.1.</span>
<span class="sd">        k (int): number of softmax values to keep for the entropy computation. Only the</span>
<span class="sd">            top-k softmax probabilities will be used. Defaults to 100.</span>
<span class="sd">        use_react (bool): if true, apply ReAct method by clipping penultimate</span>
<span class="sd">            activations under a threshold value.</span>
<span class="sd">        react_quantile (Optional[float]): q value in the range [0, 1] used to compute</span>
<span class="sd">            the react clipping threshold defined as the q-th quantile penultimate layer</span>
<span class="sd">            activations. Defaults to 0.8.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">gamma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
        <span class="n">k</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
        <span class="n">use_react</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">use_scale</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">use_ash</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">react_quantile</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">,</span>
        <span class="n">scale_percentile</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.85</span><span class="p">,</span>
        <span class="n">ash_percentile</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.90</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">use_react</span><span class="o">=</span><span class="n">use_react</span><span class="p">,</span>
            <span class="n">use_scale</span><span class="o">=</span><span class="n">use_scale</span><span class="p">,</span>
            <span class="n">use_ash</span><span class="o">=</span><span class="n">use_ash</span><span class="p">,</span>
            <span class="n">react_quantile</span><span class="o">=</span><span class="n">react_quantile</span><span class="p">,</span>
            <span class="n">scale_percentile</span><span class="o">=</span><span class="n">scale_percentile</span><span class="p">,</span>
            <span class="n">ash_percentile</span><span class="o">=</span><span class="n">ash_percentile</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">=</span> <span class="n">gamma</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">=</span> <span class="n">k</span>

    <span class="k">def</span> <span class="nf">_score_tensor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">:</span> <span class="n">TensorType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes an OOD score for input samples &quot;inputs&quot; based on</span>
<span class="sd">        the distance to nearest neighbors in the feature space of self.model</span>

<span class="sd">        Args:</span>
<span class="sd">            inputs: input samples to score</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple[np.ndarray]: scores, logits</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">_</span><span class="p">,</span> <span class="n">logits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_extractor</span><span class="o">.</span><span class="n">predict_tensor</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
        <span class="n">probs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">softmax</span><span class="p">(</span><span class="n">logits</span><span class="p">)</span>
        <span class="n">probs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">convert_to_numpy</span><span class="p">(</span><span class="n">probs</span><span class="p">)</span>
        <span class="n">probs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">probs</span><span class="p">)[:,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="p">:]</span>  <span class="c1"># Keep the k largest probabilities</span>
        <span class="n">scores</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">probs</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">probs</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gamma</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">scores</span>

    <span class="k">def</span> <span class="nf">_fit_to_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fit_dataset</span><span class="p">:</span> <span class="n">DatasetType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fits the OOD detector to fit_dataset.</span>

<span class="sd">        Args:</span>
<span class="sd">            fit_dataset: dataset to fit the OOD detector on</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">requires_to_fit_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Whether an OOD detector needs a `fit_dataset` argument in the fit function.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if `fit_dataset` is required else False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">requires_internal_features</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Whether an OOD detector acts on internal model features.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if the detector perform computations on an intermediate layer</span>
<span class="sd">            else False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">False</span>
</code></pre></div></td></tr></table></div>
        </details>

  

  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h3 id="oodeel.methods.gen.GEN.requires_internal_features" class="doc doc-heading">
<code class="highlight language-python"><span class="n">requires_internal_features</span><span class="p">:</span> <span class="nb">bool</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

<a href="#oodeel.methods.gen.GEN.requires_internal_features" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Whether an OOD detector acts on internal model features.</p>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>bool</code></td>          <td>
                <code>bool</code>
          </td>
          <td><p>True if the detector perform computations on an intermediate layer</p></td>
        </tr>
        <tr>
<td></td>          <td>
                <code>bool</code>
          </td>
          <td><p>else False.</p></td>
        </tr>
    </tbody>
  </table>
  </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="oodeel.methods.gen.GEN.requires_to_fit_dataset" class="doc doc-heading">
<code class="highlight language-python"><span class="n">requires_to_fit_dataset</span><span class="p">:</span> <span class="nb">bool</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

<a href="#oodeel.methods.gen.GEN.requires_to_fit_dataset" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Whether an OOD detector needs a <code>fit_dataset</code> argument in the fit function.</p>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>bool</code></td>          <td>
                <code>bool</code>
          </td>
          <td><p>True if <code>fit_dataset</code> is required else False.</p></td>
        </tr>
    </tbody>
  </table>
  </div>

</div>



<div class="doc doc-object doc-function">



<h3 id="oodeel.methods.gen.GEN._fit_to_dataset" class="doc doc-heading">
<code class="highlight language-python"><span class="n">_fit_to_dataset</span><span class="p">(</span><span class="n">fit_dataset</span><span class="p">)</span></code>

<a href="#oodeel.methods.gen.GEN._fit_to_dataset" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Fits the OOD detector to fit_dataset.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>fit_dataset</code></td>
          <td>
                <code><span title="oodeel.types.DatasetType">DatasetType</span></code>
          </td>
          <td><p>dataset to fit the OOD detector on</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>oodeel/methods/gen.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">90</span>
<span class="normal">91</span>
<span class="normal">92</span>
<span class="normal">93</span>
<span class="normal">94</span>
<span class="normal">95</span>
<span class="normal">96</span>
<span class="normal">97</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">_fit_to_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fit_dataset</span><span class="p">:</span> <span class="n">DatasetType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fits the OOD detector to fit_dataset.</span>

<span class="sd">    Args:</span>
<span class="sd">        fit_dataset: dataset to fit the OOD detector on</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h3 id="oodeel.methods.gen.GEN._score_tensor" class="doc doc-heading">
<code class="highlight language-python"><span class="n">_score_tensor</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span></code>

<a href="#oodeel.methods.gen.GEN._score_tensor" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Computes an OOD score for input samples "inputs" based on
the distance to nearest neighbors in the feature space of self.model</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>inputs</code></td>
          <td>
                <code><span title="oodeel.types.TensorType">TensorType</span></code>
          </td>
          <td><p>input samples to score</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code><span title="oodeel.types.Tuple">Tuple</span>[<span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span>]</code>
          </td>
          <td><p>Tuple[np.ndarray]: scores, logits</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>oodeel/methods/gen.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">71</span>
<span class="normal">72</span>
<span class="normal">73</span>
<span class="normal">74</span>
<span class="normal">75</span>
<span class="normal">76</span>
<span class="normal">77</span>
<span class="normal">78</span>
<span class="normal">79</span>
<span class="normal">80</span>
<span class="normal">81</span>
<span class="normal">82</span>
<span class="normal">83</span>
<span class="normal">84</span>
<span class="normal">85</span>
<span class="normal">86</span>
<span class="normal">87</span>
<span class="normal">88</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">_score_tensor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">:</span> <span class="n">TensorType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes an OOD score for input samples &quot;inputs&quot; based on</span>
<span class="sd">    the distance to nearest neighbors in the feature space of self.model</span>

<span class="sd">    Args:</span>
<span class="sd">        inputs: input samples to score</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple[np.ndarray]: scores, logits</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_</span><span class="p">,</span> <span class="n">logits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_extractor</span><span class="o">.</span><span class="n">predict_tensor</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
    <span class="n">probs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">softmax</span><span class="p">(</span><span class="n">logits</span><span class="p">)</span>
    <span class="n">probs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">convert_to_numpy</span><span class="p">(</span><span class="n">probs</span><span class="p">)</span>
    <span class="n">probs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">probs</span><span class="p">)[:,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="p">:]</span>  <span class="c1"># Keep the k largest probabilities</span>
    <span class="n">scores</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">probs</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">probs</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gamma</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">scores</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>



  </div>

  </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="oodeel.methods.Gram" class="doc doc-heading">
        <code>Gram</code>


<a href="#oodeel.methods.Gram" class="headerlink" title="Permanent link">&para;</a></h2>


  <div class="doc doc-contents ">
      <p class="doc doc-class-bases">
        Bases: <code><a class="autorefs autorefs-internal" title="oodeel.methods.base.OODBaseDetector" href="#oodeel.methods.base.OODBaseDetector">OODBaseDetector</a></code></p>

  
      <p>"Detecting Out-of-Distribution Examples with Gram Matrices"
<a href="https://proceedings.mlr.press/v119/sastry20a.html">link</a></p>
<p><strong>Important Disclaimer</strong>: Taking the statistics of min/max deviation,
as in the paper raises some problems.</p>
<p>The method often yields a score of zero for some tasks.
This is expected since the min/max among the samples of a random
variable becomes more and more extreme with the sample
size. As a result, computing the min/max over the training set is likely to produce
min/max values that are so extreme that none of the in distribution correlations of
the validation set goes beyond these threshold. The worst is that a significant
part of ood data does not exceed the thresholds either. This can be aleviated by
computing the min/max over a limited number of sample. However, it is
counter-intuitive and, in our opinion, not desirable: adding
some more information should only improve a method.</p>
<p>Hence, we decided to replace the min/max by the q / 1-q quantile, with q a new
parameter of the method. Specifically, instead of the deviation as defined in
eq. 3 of the paper, we use the definition
$$
\delta(t_q, t_{1-q}, value) =
\begin{cases}
    0 &amp; \text{if} \; t_q \leq value \leq t_{1-q},  \;\;
    \frac{t_q - value}{|t_q|} &amp; \text{if } value &lt; t_q,  \;\;
    \frac{value - t_{1-q}}{|t_q|} &amp; \text{if } value &gt; t_{1-q}
\end{cases}
$$
With this new deviation, the more point we add, the more accurate the quantile
becomes. In addition, the method can be made more or less discriminative by
toggling the value of q.</p>
<p>Finally, we found that this approach improved the performance of the baseline in
our experiments.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>orders</code></td>
          <td>
                <code><span title="oodeel.types.List">List</span>[int]</code>
          </td>
          <td><p>power orders to consider for the correlation matrix</p></td>
          <td>
                <code>[i for i in range(1, 6)]</code>
          </td>
        </tr>
        <tr>
          <td><code>quantile</code></td>
          <td>
                <code>float</code>
          </td>
          <td><p>quantile to consider for the correlations to build the
deviation threshold.</p></td>
          <td>
                <code>0.01</code>
          </td>
        </tr>
    </tbody>
  </table>


        <details class="quote">
          <summary>Source code in <code>oodeel/methods/gram.py</code></summary>
          <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 33</span>
<span class="normal"> 34</span>
<span class="normal"> 35</span>
<span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">Gram</span><span class="p">(</span><span class="n">OODBaseDetector</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &quot;Detecting Out-of-Distribution Examples with Gram Matrices&quot;</span>
<span class="sd">    [link](https://proceedings.mlr.press/v119/sastry20a.html)</span>

<span class="sd">    **Important Disclaimer**: Taking the statistics of min/max deviation,</span>
<span class="sd">    as in the paper raises some problems.</span>

<span class="sd">    The method often yields a score of zero for some tasks.</span>
<span class="sd">    This is expected since the min/max among the samples of a random</span>
<span class="sd">    variable becomes more and more extreme with the sample</span>
<span class="sd">    size. As a result, computing the min/max over the training set is likely to produce</span>
<span class="sd">    min/max values that are so extreme that none of the in distribution correlations of</span>
<span class="sd">    the validation set goes beyond these threshold. The worst is that a significant</span>
<span class="sd">    part of ood data does not exceed the thresholds either. This can be aleviated by</span>
<span class="sd">    computing the min/max over a limited number of sample. However, it is</span>
<span class="sd">    counter-intuitive and, in our opinion, not desirable: adding</span>
<span class="sd">    some more information should only improve a method.</span>

<span class="sd">    Hence, we decided to replace the min/max by the q / 1-q quantile, with q a new</span>
<span class="sd">    parameter of the method. Specifically, instead of the deviation as defined in</span>
<span class="sd">    eq. 3 of the paper, we use the definition</span>
<span class="sd">    $$</span>
<span class="sd">    \delta(t_q, t_{1-q}, value) =</span>
<span class="sd">    \begin{cases}</span>
<span class="sd">        0 &amp; \text{if} \; t_q \leq value \leq t_{1-q},  \;\;</span>
<span class="sd">        \frac{t_q - value}{|t_q|} &amp; \text{if } value &lt; t_q,  \;\;</span>
<span class="sd">        \frac{value - t_{1-q}}{|t_q|} &amp; \text{if } value &gt; t_{1-q}</span>
<span class="sd">    \end{cases}</span>
<span class="sd">    $$</span>
<span class="sd">    With this new deviation, the more point we add, the more accurate the quantile</span>
<span class="sd">    becomes. In addition, the method can be made more or less discriminative by</span>
<span class="sd">    toggling the value of q.</span>

<span class="sd">    Finally, we found that this approach improved the performance of the baseline in</span>
<span class="sd">    our experiments.</span>

<span class="sd">    Args:</span>
<span class="sd">        orders (List[int]): power orders to consider for the correlation matrix</span>
<span class="sd">        quantile (float): quantile to consider for the correlations to build the</span>
<span class="sd">            deviation threshold.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">orders</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">)],</span>
        <span class="n">quantile</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">orders</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">orders</span> <span class="o">=</span> <span class="p">[</span><span class="n">orders</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">orders</span> <span class="o">=</span> <span class="n">orders</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">postproc_fns</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quantile</span> <span class="o">=</span> <span class="n">quantile</span>

    <span class="k">def</span> <span class="nf">_fit_to_dataset</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">fit_dataset</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">TensorType</span><span class="p">,</span> <span class="n">DatasetType</span><span class="p">],</span>
        <span class="n">val_split</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the quantiles of channelwise correlations for each layer, power of</span>
<span class="sd">        gram matrices, and class. Then, compute the normalization constants for the</span>
<span class="sd">        deviation. To stay faithful to the spirit of the original method, we still name</span>
<span class="sd">        the quantiles min/max</span>

<span class="sd">        Args:</span>
<span class="sd">            fit_dataset (Union[TensorType, DatasetType]): input dataset (ID) to</span>
<span class="sd">                construct the index with.</span>
<span class="sd">            val_split (float): The percentage of fit data to use as validation data for</span>
<span class="sd">                normalization. Default to 0.2.</span>
<span class="sd">            verbose (bool): Whether to print information during the fitting process.</span>
<span class="sd">                Default to False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">postproc_fns</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_stat</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">feature_extractor</span><span class="o">.</span><span class="n">feature_layers_id</span><span class="p">))</span>
        <span class="p">]</span>

        <span class="c1"># fit_stats shape: [n_features, n_samples, n_orders, n_channels]</span>
        <span class="n">fit_stats</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_extractor</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span>
            <span class="n">fit_dataset</span><span class="p">,</span>
            <span class="n">postproc_fns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">postproc_fns</span><span class="p">,</span>
            <span class="n">return_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s2">&quot;labels&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_classes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">convert_to_numpy</span><span class="p">(</span><span class="n">labels</span><span class="p">)))</span>

        <span class="n">full_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">labels</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">train_indices</span><span class="p">,</span> <span class="n">val_indices</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">full_indices</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="n">val_split</span><span class="p">)</span>
        <span class="n">train_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span>
            <span class="p">[</span><span class="nb">bool</span><span class="p">(</span><span class="n">ind</span> <span class="ow">in</span> <span class="n">train_indices</span><span class="p">)</span> <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">full_indices</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">val_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span>
            <span class="p">[</span><span class="nb">bool</span><span class="p">(</span><span class="n">ind</span> <span class="ow">in</span> <span class="n">val_indices</span><span class="p">)</span> <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">full_indices</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="n">val_stats</span> <span class="o">=</span> <span class="p">[</span><span class="n">fit_stat</span><span class="p">[</span><span class="n">val_indices</span><span class="p">]</span> <span class="k">for</span> <span class="n">fit_stat</span> <span class="ow">in</span> <span class="n">fit_stats</span><span class="p">]</span>
        <span class="n">fit_stats</span> <span class="o">=</span> <span class="p">[</span><span class="n">fit_stat</span><span class="p">[</span><span class="n">train_indices</span><span class="p">]</span> <span class="k">for</span> <span class="n">fit_stat</span> <span class="ow">in</span> <span class="n">fit_stats</span><span class="p">]</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="n">train_indices</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">min_maxs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_classes</span><span class="p">:</span>
            <span class="n">indexes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span>
            <span class="n">min_maxs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">fit_stat</span> <span class="ow">in</span> <span class="n">fit_stats</span><span class="p">:</span>
                <span class="n">fit_stat</span> <span class="o">=</span> <span class="n">fit_stat</span><span class="p">[</span><span class="n">indexes</span><span class="p">]</span>
                <span class="n">mins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">fit_stat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">quantile</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span>
                <span class="p">)</span>
                <span class="n">maxs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">fit_stat</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">quantile</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span>
                <span class="p">)</span>
                <span class="n">min_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">mins</span><span class="p">,</span> <span class="n">maxs</span><span class="p">],</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">min_maxs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">min_max</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">min_maxs</span><span class="p">[</span><span class="bp">cls</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_maxs</span>

        <span class="n">devnorm</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_classes</span><span class="p">:</span>
            <span class="n">min_maxs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">min_max</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_maxs</span><span class="p">[</span><span class="bp">cls</span><span class="p">]:</span>
                <span class="n">min_maxs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">min_max</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">val_stats</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])])</span>
                <span class="p">)</span>
            <span class="n">devnorm</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
                    <span class="k">for</span> <span class="n">dev</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deviation</span><span class="p">(</span><span class="n">val_stats</span><span class="p">,</span> <span class="n">min_maxs</span><span class="p">)</span>
                <span class="p">]</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">devnorm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">devnorm</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_score_tensor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">:</span> <span class="n">TensorType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes an OOD score for input samples &quot;inputs&quot; based on</span>
<span class="sd">        the aggregation of deviations from quantiles of in-distribution channel-wise</span>
<span class="sd">        correlations evaluate for each layer, power of gram matrices, and class.</span>

<span class="sd">        Args:</span>
<span class="sd">            inputs: input samples to score</span>

<span class="sd">        Returns:</span>
<span class="sd">            scores</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">tensor_stats</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_extractor</span><span class="o">.</span><span class="n">predict_tensor</span><span class="p">(</span>
            <span class="n">inputs</span><span class="p">,</span> <span class="n">postproc_fns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">postproc_fns</span>
        <span class="p">)</span>

        <span class="n">_</span><span class="p">,</span> <span class="n">logits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_extractor</span><span class="o">.</span><span class="n">predict_tensor</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
        <span class="n">preds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">convert_to_numpy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">logits</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

        <span class="c1"># We stack the min_maxs for each class depending on the prediction for each</span>
        <span class="c1"># samples</span>
        <span class="n">min_maxs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tensor_stats</span><span class="p">)):</span>
            <span class="n">min_maxs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">min_maxs</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">preds</span><span class="p">]))</span>

        <span class="n">tensor_dev</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deviation</span><span class="p">(</span><span class="n">tensor_stats</span><span class="p">,</span> <span class="n">min_maxs</span><span class="p">)</span>
        <span class="n">score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="n">tensor_dev_l</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">devnorm_l</span>
                    <span class="k">for</span> <span class="n">tensor_dev_l</span><span class="p">,</span> <span class="n">devnorm_l</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">tensor_dev</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">devnorm</span><span class="p">)</span>
                <span class="p">]</span>
            <span class="p">),</span>
            <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">convert_to_numpy</span><span class="p">(</span><span class="n">score</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_deviation</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">stats</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">TensorType</span><span class="p">],</span> <span class="n">min_maxs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">TensorType</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">TensorType</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the deviation wrt quantiles (min/max) for feature_maps</span>

<span class="sd">        Args:</span>
<span class="sd">            stats (TensorType): The list of gram matrices (stacked power-wise)</span>
<span class="sd">                for which we want to compute the deviation.</span>
<span class="sd">            min_maxs (TensorType): The quantiles (tensorised) to compute the deviation</span>
<span class="sd">                against.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List(TensorType): A list with one element per layer containing a tensor of</span>
<span class="sd">                per-sample deviation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">deviation</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">stat</span><span class="p">,</span> <span class="n">min_max</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">stats</span><span class="p">,</span> <span class="n">min_maxs</span><span class="p">):</span>
            <span class="n">where_min</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">stat</span> <span class="o">&lt;</span> <span class="n">min_max</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
            <span class="n">where_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">stat</span> <span class="o">&gt;</span> <span class="n">min_max</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
            <span class="n">deviation_min</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">min_max</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">stat</span><span class="p">)</span>
                <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">min_max</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="mf">1e-6</span><span class="p">)</span>
                <span class="o">*</span> <span class="n">where_min</span>
            <span class="p">)</span>
            <span class="n">deviation_max</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">stat</span> <span class="o">-</span> <span class="n">min_max</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
                <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">min_max</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="mf">1e-6</span><span class="p">)</span>
                <span class="o">*</span> <span class="n">where_max</span>
            <span class="p">)</span>
            <span class="n">deviation</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">deviation_min</span> <span class="o">+</span> <span class="n">deviation_max</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">deviation</span>

    <span class="k">def</span> <span class="nf">_stat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">feature_map</span><span class="p">:</span> <span class="n">TensorType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TensorType</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the correlation map (stat) for a given feature map. The values</span>
<span class="sd">        for each power of gram matrix are contained in the same tensor</span>

<span class="sd">        Args:</span>
<span class="sd">            feature_map (TensorType): The input feature_map</span>

<span class="sd">        Returns:</span>
<span class="sd">            TensorType: The stacked gram matrices power-wise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fm_s</span> <span class="o">=</span> <span class="n">feature_map</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">stat</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">orders</span><span class="p">:</span>
            <span class="n">feature_map_p</span> <span class="o">=</span> <span class="n">feature_map</span><span class="o">**</span><span class="n">p</span>
            <span class="c1"># construct the Gram matrix</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fm_s</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># build gram matrix for feature map of shape [dim_dense_layer, 1]</span>
                <span class="n">feature_map_p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span>
                    <span class="s2">&quot;bi,bj-&gt;bij&quot;</span><span class="p">,</span> <span class="n">feature_map_p</span><span class="p">,</span> <span class="n">feature_map_p</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">fm_s</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
                <span class="c1"># flatten the feature map</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">backend</span> <span class="o">==</span> <span class="s2">&quot;tensorflow&quot;</span><span class="p">:</span>
                    <span class="n">feature_map_p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;i...j-&gt;ij...&quot;</span><span class="p">,</span> <span class="n">feature_map_p</span><span class="p">),</span>
                        <span class="p">(</span><span class="n">fm_s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fm_s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># batch, channel, spatial</span>
                    <span class="n">feature_map_p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                        <span class="n">feature_map_p</span><span class="p">,</span> <span class="p">(</span><span class="n">fm_s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fm_s</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="c1"># batch, channel, channel</span>
                <span class="n">feature_map_p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span>
                    <span class="n">feature_map_p</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="n">feature_map_p</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
                <span class="p">)</span>
            <span class="c1"># normalize the Gram matrix</span>
            <span class="n">feature_map_p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">feature_map_p</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">feature_map_p</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">p</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="c1"># get the lower triangular part of the matrix</span>
            <span class="n">feature_map_p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">tril</span><span class="p">(</span><span class="n">feature_map_p</span><span class="p">)</span>
            <span class="c1"># directly sum row-wise (to limit computational burden) -&gt; batch, channel</span>
            <span class="n">feature_map_p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">feature_map_p</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="c1"># stat.append(self.op.t(feature_map_p))</span>
            <span class="n">stat</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">feature_map_p</span><span class="p">)</span>
        <span class="c1"># batch, n_orders, channel</span>
        <span class="n">stat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">stat</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">stat</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">requires_to_fit_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Whether an OOD detector needs a `fit_dataset` argument in the fit function.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if `fit_dataset` is required else False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">requires_internal_features</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Whether an OOD detector acts on internal model features.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if the detector perform computations on an intermediate layer</span>
<span class="sd">            else False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">True</span>
</code></pre></div></td></tr></table></div>
        </details>

  

  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h3 id="oodeel.methods.gram.Gram.requires_internal_features" class="doc doc-heading">
<code class="highlight language-python"><span class="n">requires_internal_features</span><span class="p">:</span> <span class="nb">bool</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

<a href="#oodeel.methods.gram.Gram.requires_internal_features" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Whether an OOD detector acts on internal model features.</p>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>bool</code></td>          <td>
                <code>bool</code>
          </td>
          <td><p>True if the detector perform computations on an intermediate layer</p></td>
        </tr>
        <tr>
<td></td>          <td>
                <code>bool</code>
          </td>
          <td><p>else False.</p></td>
        </tr>
    </tbody>
  </table>
  </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="oodeel.methods.gram.Gram.requires_to_fit_dataset" class="doc doc-heading">
<code class="highlight language-python"><span class="n">requires_to_fit_dataset</span><span class="p">:</span> <span class="nb">bool</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

<a href="#oodeel.methods.gram.Gram.requires_to_fit_dataset" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Whether an OOD detector needs a <code>fit_dataset</code> argument in the fit function.</p>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>bool</code></td>          <td>
                <code>bool</code>
          </td>
          <td><p>True if <code>fit_dataset</code> is required else False.</p></td>
        </tr>
    </tbody>
  </table>
  </div>

</div>



<div class="doc doc-object doc-function">



<h3 id="oodeel.methods.gram.Gram._deviation" class="doc doc-heading">
<code class="highlight language-python"><span class="n">_deviation</span><span class="p">(</span><span class="n">stats</span><span class="p">,</span> <span class="n">min_maxs</span><span class="p">)</span></code>

<a href="#oodeel.methods.gram.Gram._deviation" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Compute the deviation wrt quantiles (min/max) for feature_maps</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>stats</code></td>
          <td>
                <code><span title="oodeel.types.TensorType">TensorType</span></code>
          </td>
          <td><p>The list of gram matrices (stacked power-wise)
for which we want to compute the deviation.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>min_maxs</code></td>
          <td>
                <code><span title="oodeel.types.TensorType">TensorType</span></code>
          </td>
          <td><p>The quantiles (tensorised) to compute the deviation
against.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>List</code></td>          <td>
                <code><span title="oodeel.types.TensorType">TensorType</span></code>
          </td>
          <td><p>A list with one element per layer containing a tensor of
per-sample deviation.</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>oodeel/methods/gram.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">_deviation</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">stats</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">TensorType</span><span class="p">],</span> <span class="n">min_maxs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">TensorType</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">TensorType</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the deviation wrt quantiles (min/max) for feature_maps</span>

<span class="sd">    Args:</span>
<span class="sd">        stats (TensorType): The list of gram matrices (stacked power-wise)</span>
<span class="sd">            for which we want to compute the deviation.</span>
<span class="sd">        min_maxs (TensorType): The quantiles (tensorised) to compute the deviation</span>
<span class="sd">            against.</span>

<span class="sd">    Returns:</span>
<span class="sd">        List(TensorType): A list with one element per layer containing a tensor of</span>
<span class="sd">            per-sample deviation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">deviation</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">stat</span><span class="p">,</span> <span class="n">min_max</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">stats</span><span class="p">,</span> <span class="n">min_maxs</span><span class="p">):</span>
        <span class="n">where_min</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">stat</span> <span class="o">&lt;</span> <span class="n">min_max</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="n">where_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">stat</span> <span class="o">&gt;</span> <span class="n">min_max</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="n">deviation_min</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">min_max</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">stat</span><span class="p">)</span>
            <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">min_max</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="mf">1e-6</span><span class="p">)</span>
            <span class="o">*</span> <span class="n">where_min</span>
        <span class="p">)</span>
        <span class="n">deviation_max</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">stat</span> <span class="o">-</span> <span class="n">min_max</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">min_max</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="mf">1e-6</span><span class="p">)</span>
            <span class="o">*</span> <span class="n">where_max</span>
        <span class="p">)</span>
        <span class="n">deviation</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">deviation_min</span> <span class="o">+</span> <span class="n">deviation_max</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">deviation</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h3 id="oodeel.methods.gram.Gram._fit_to_dataset" class="doc doc-heading">
<code class="highlight language-python"><span class="n">_fit_to_dataset</span><span class="p">(</span><span class="n">fit_dataset</span><span class="p">,</span> <span class="n">val_split</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

<a href="#oodeel.methods.gram.Gram._fit_to_dataset" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Compute the quantiles of channelwise correlations for each layer, power of
gram matrices, and class. Then, compute the normalization constants for the
deviation. To stay faithful to the spirit of the original method, we still name
the quantiles min/max</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>fit_dataset</code></td>
          <td>
                <code><span title="oodeel.types.Union">Union</span>[<span title="oodeel.types.TensorType">TensorType</span>, <span title="oodeel.types.DatasetType">DatasetType</span>]</code>
          </td>
          <td><p>input dataset (ID) to
construct the index with.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>val_split</code></td>
          <td>
                <code>float</code>
          </td>
          <td><p>The percentage of fit data to use as validation data for
normalization. Default to 0.2.</p></td>
          <td>
                <code>0.2</code>
          </td>
        </tr>
        <tr>
          <td><code>verbose</code></td>
          <td>
                <code>bool</code>
          </td>
          <td><p>Whether to print information during the fitting process.
Default to False.</p></td>
          <td>
                <code>False</code>
          </td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>oodeel/methods/gram.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">_fit_to_dataset</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">fit_dataset</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">TensorType</span><span class="p">,</span> <span class="n">DatasetType</span><span class="p">],</span>
    <span class="n">val_split</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span>
    <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the quantiles of channelwise correlations for each layer, power of</span>
<span class="sd">    gram matrices, and class. Then, compute the normalization constants for the</span>
<span class="sd">    deviation. To stay faithful to the spirit of the original method, we still name</span>
<span class="sd">    the quantiles min/max</span>

<span class="sd">    Args:</span>
<span class="sd">        fit_dataset (Union[TensorType, DatasetType]): input dataset (ID) to</span>
<span class="sd">            construct the index with.</span>
<span class="sd">        val_split (float): The percentage of fit data to use as validation data for</span>
<span class="sd">            normalization. Default to 0.2.</span>
<span class="sd">        verbose (bool): Whether to print information during the fitting process.</span>
<span class="sd">            Default to False.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">postproc_fns</span> <span class="o">=</span> <span class="p">[</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_stat</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">feature_extractor</span><span class="o">.</span><span class="n">feature_layers_id</span><span class="p">))</span>
    <span class="p">]</span>

    <span class="c1"># fit_stats shape: [n_features, n_samples, n_orders, n_channels]</span>
    <span class="n">fit_stats</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_extractor</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span>
        <span class="n">fit_dataset</span><span class="p">,</span>
        <span class="n">postproc_fns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">postproc_fns</span><span class="p">,</span>
        <span class="n">return_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s2">&quot;labels&quot;</span><span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_classes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">convert_to_numpy</span><span class="p">(</span><span class="n">labels</span><span class="p">)))</span>

    <span class="n">full_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">labels</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">train_indices</span><span class="p">,</span> <span class="n">val_indices</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">full_indices</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="n">val_split</span><span class="p">)</span>
    <span class="n">train_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span>
        <span class="p">[</span><span class="nb">bool</span><span class="p">(</span><span class="n">ind</span> <span class="ow">in</span> <span class="n">train_indices</span><span class="p">)</span> <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">full_indices</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">val_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span>
        <span class="p">[</span><span class="nb">bool</span><span class="p">(</span><span class="n">ind</span> <span class="ow">in</span> <span class="n">val_indices</span><span class="p">)</span> <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">full_indices</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="n">val_stats</span> <span class="o">=</span> <span class="p">[</span><span class="n">fit_stat</span><span class="p">[</span><span class="n">val_indices</span><span class="p">]</span> <span class="k">for</span> <span class="n">fit_stat</span> <span class="ow">in</span> <span class="n">fit_stats</span><span class="p">]</span>
    <span class="n">fit_stats</span> <span class="o">=</span> <span class="p">[</span><span class="n">fit_stat</span><span class="p">[</span><span class="n">train_indices</span><span class="p">]</span> <span class="k">for</span> <span class="n">fit_stat</span> <span class="ow">in</span> <span class="n">fit_stats</span><span class="p">]</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="n">train_indices</span><span class="p">]</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">min_maxs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_classes</span><span class="p">:</span>
        <span class="n">indexes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span>
        <span class="n">min_maxs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">fit_stat</span> <span class="ow">in</span> <span class="n">fit_stats</span><span class="p">:</span>
            <span class="n">fit_stat</span> <span class="o">=</span> <span class="n">fit_stat</span><span class="p">[</span><span class="n">indexes</span><span class="p">]</span>
            <span class="n">mins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">fit_stat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">quantile</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span>
            <span class="p">)</span>
            <span class="n">maxs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">fit_stat</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">quantile</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span>
            <span class="p">)</span>
            <span class="n">min_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">mins</span><span class="p">,</span> <span class="n">maxs</span><span class="p">],</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">min_maxs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">min_max</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">min_maxs</span><span class="p">[</span><span class="bp">cls</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_maxs</span>

    <span class="n">devnorm</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_classes</span><span class="p">:</span>
        <span class="n">min_maxs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">min_max</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_maxs</span><span class="p">[</span><span class="bp">cls</span><span class="p">]:</span>
            <span class="n">min_maxs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">min_max</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">val_stats</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])])</span>
            <span class="p">)</span>
        <span class="n">devnorm</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">dev</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deviation</span><span class="p">(</span><span class="n">val_stats</span><span class="p">,</span> <span class="n">min_maxs</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">devnorm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">devnorm</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h3 id="oodeel.methods.gram.Gram._score_tensor" class="doc doc-heading">
<code class="highlight language-python"><span class="n">_score_tensor</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span></code>

<a href="#oodeel.methods.gram.Gram._score_tensor" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Computes an OOD score for input samples "inputs" based on
the aggregation of deviations from quantiles of in-distribution channel-wise
correlations evaluate for each layer, power of gram matrices, and class.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>inputs</code></td>
          <td>
                <code><span title="oodeel.types.TensorType">TensorType</span></code>
          </td>
          <td><p>input samples to score</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>scores</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>oodeel/methods/gram.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">_score_tensor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">:</span> <span class="n">TensorType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes an OOD score for input samples &quot;inputs&quot; based on</span>
<span class="sd">    the aggregation of deviations from quantiles of in-distribution channel-wise</span>
<span class="sd">    correlations evaluate for each layer, power of gram matrices, and class.</span>

<span class="sd">    Args:</span>
<span class="sd">        inputs: input samples to score</span>

<span class="sd">    Returns:</span>
<span class="sd">        scores</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">tensor_stats</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_extractor</span><span class="o">.</span><span class="n">predict_tensor</span><span class="p">(</span>
        <span class="n">inputs</span><span class="p">,</span> <span class="n">postproc_fns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">postproc_fns</span>
    <span class="p">)</span>

    <span class="n">_</span><span class="p">,</span> <span class="n">logits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_extractor</span><span class="o">.</span><span class="n">predict_tensor</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
    <span class="n">preds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">convert_to_numpy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">logits</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

    <span class="c1"># We stack the min_maxs for each class depending on the prediction for each</span>
    <span class="c1"># samples</span>
    <span class="n">min_maxs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tensor_stats</span><span class="p">)):</span>
        <span class="n">min_maxs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">min_maxs</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">preds</span><span class="p">]))</span>

    <span class="n">tensor_dev</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deviation</span><span class="p">(</span><span class="n">tensor_stats</span><span class="p">,</span> <span class="n">min_maxs</span><span class="p">)</span>
    <span class="n">score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="n">tensor_dev_l</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">devnorm_l</span>
                <span class="k">for</span> <span class="n">tensor_dev_l</span><span class="p">,</span> <span class="n">devnorm_l</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">tensor_dev</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">devnorm</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="p">),</span>
        <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">convert_to_numpy</span><span class="p">(</span><span class="n">score</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h3 id="oodeel.methods.gram.Gram._stat" class="doc doc-heading">
<code class="highlight language-python"><span class="n">_stat</span><span class="p">(</span><span class="n">feature_map</span><span class="p">)</span></code>

<a href="#oodeel.methods.gram.Gram._stat" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Compute the correlation map (stat) for a given feature map. The values
for each power of gram matrix are contained in the same tensor</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>feature_map</code></td>
          <td>
                <code><span title="oodeel.types.TensorType">TensorType</span></code>
          </td>
          <td><p>The input feature_map</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>TensorType</code></td>          <td>
                <code><span title="oodeel.types.TensorType">TensorType</span></code>
          </td>
          <td><p>The stacked gram matrices power-wise.</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>oodeel/methods/gram.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">_stat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">feature_map</span><span class="p">:</span> <span class="n">TensorType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TensorType</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the correlation map (stat) for a given feature map. The values</span>
<span class="sd">    for each power of gram matrix are contained in the same tensor</span>

<span class="sd">    Args:</span>
<span class="sd">        feature_map (TensorType): The input feature_map</span>

<span class="sd">    Returns:</span>
<span class="sd">        TensorType: The stacked gram matrices power-wise.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fm_s</span> <span class="o">=</span> <span class="n">feature_map</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">stat</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">orders</span><span class="p">:</span>
        <span class="n">feature_map_p</span> <span class="o">=</span> <span class="n">feature_map</span><span class="o">**</span><span class="n">p</span>
        <span class="c1"># construct the Gram matrix</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fm_s</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># build gram matrix for feature map of shape [dim_dense_layer, 1]</span>
            <span class="n">feature_map_p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span>
                <span class="s2">&quot;bi,bj-&gt;bij&quot;</span><span class="p">,</span> <span class="n">feature_map_p</span><span class="p">,</span> <span class="n">feature_map_p</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">fm_s</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="c1"># flatten the feature map</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">backend</span> <span class="o">==</span> <span class="s2">&quot;tensorflow&quot;</span><span class="p">:</span>
                <span class="n">feature_map_p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;i...j-&gt;ij...&quot;</span><span class="p">,</span> <span class="n">feature_map_p</span><span class="p">),</span>
                    <span class="p">(</span><span class="n">fm_s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fm_s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># batch, channel, spatial</span>
                <span class="n">feature_map_p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                    <span class="n">feature_map_p</span><span class="p">,</span> <span class="p">(</span><span class="n">fm_s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fm_s</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="c1"># batch, channel, channel</span>
            <span class="n">feature_map_p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span>
                <span class="n">feature_map_p</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="n">feature_map_p</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="c1"># normalize the Gram matrix</span>
        <span class="n">feature_map_p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">feature_map_p</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">feature_map_p</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">p</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="c1"># get the lower triangular part of the matrix</span>
        <span class="n">feature_map_p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">tril</span><span class="p">(</span><span class="n">feature_map_p</span><span class="p">)</span>
        <span class="c1"># directly sum row-wise (to limit computational burden) -&gt; batch, channel</span>
        <span class="n">feature_map_p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">feature_map_p</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="c1"># stat.append(self.op.t(feature_map_p))</span>
        <span class="n">stat</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">feature_map_p</span><span class="p">)</span>
    <span class="c1"># batch, n_orders, channel</span>
    <span class="n">stat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">stat</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">stat</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>



  </div>

  </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="oodeel.methods.MLS" class="doc doc-heading">
        <code>MLS</code>


<a href="#oodeel.methods.MLS" class="headerlink" title="Permanent link">&para;</a></h2>


  <div class="doc doc-contents ">
      <p class="doc doc-class-bases">
        Bases: <code><a class="autorefs autorefs-internal" title="oodeel.methods.base.OODBaseDetector" href="#oodeel.methods.base.OODBaseDetector">OODBaseDetector</a></code></p>

  
      <p>Maximum Logit Scores method for OOD detection.
"Open-Set Recognition: a Good Closed-Set Classifier is All You Need?"
https://arxiv.org/abs/2110.06207,
and Maximum Softmax Score
"A Baseline for Detecting Misclassified and Out-of-Distribution Examples
in Neural Networks"
http://arxiv.org/abs/1610.02136</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>output_activation</code></td>
          <td>
                <code>str</code>
          </td>
          <td><p>activation function for the last layer. If "linear",
the method is MLS and if "softmax", the method is MSS.
Defaults to "linear".</p></td>
          <td>
                <code>&#39;linear&#39;</code>
          </td>
        </tr>
        <tr>
          <td><code>use_react</code></td>
          <td>
                <code>bool</code>
          </td>
          <td><p>if true, apply ReAct method by clipping penultimate
activations under a threshold value.</p></td>
          <td>
                <code>False</code>
          </td>
        </tr>
        <tr>
          <td><code>react_quantile</code></td>
          <td>
                <code>Optional[float]</code>
          </td>
          <td><p>q value in the range [0, 1] used to compute
the react clipping threshold defined as the q-th quantile penultimate layer
activations. Defaults to 0.8.</p></td>
          <td>
                <code>0.8</code>
          </td>
        </tr>
    </tbody>
  </table>


        <details class="quote">
          <summary>Source code in <code>oodeel/methods/mls.py</code></summary>
          <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 31</span>
<span class="normal"> 32</span>
<span class="normal"> 33</span>
<span class="normal"> 34</span>
<span class="normal"> 35</span>
<span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">MLS</span><span class="p">(</span><span class="n">OODBaseDetector</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Maximum Logit Scores method for OOD detection.</span>
<span class="sd">    &quot;Open-Set Recognition: a Good Closed-Set Classifier is All You Need?&quot;</span>
<span class="sd">    https://arxiv.org/abs/2110.06207,</span>
<span class="sd">    and Maximum Softmax Score</span>
<span class="sd">    &quot;A Baseline for Detecting Misclassified and Out-of-Distribution Examples</span>
<span class="sd">    in Neural Networks&quot;</span>
<span class="sd">    http://arxiv.org/abs/1610.02136</span>

<span class="sd">    Args:</span>
<span class="sd">        output_activation (str): activation function for the last layer. If &quot;linear&quot;,</span>
<span class="sd">            the method is MLS and if &quot;softmax&quot;, the method is MSS.</span>
<span class="sd">            Defaults to &quot;linear&quot;.</span>
<span class="sd">        use_react (bool): if true, apply ReAct method by clipping penultimate</span>
<span class="sd">            activations under a threshold value.</span>
<span class="sd">        react_quantile (Optional[float]): q value in the range [0, 1] used to compute</span>
<span class="sd">            the react clipping threshold defined as the q-th quantile penultimate layer</span>
<span class="sd">            activations. Defaults to 0.8.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">output_activation</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;linear&quot;</span><span class="p">,</span>
        <span class="n">use_react</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">use_scale</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">use_ash</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">react_quantile</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">,</span>
        <span class="n">scale_percentile</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.85</span><span class="p">,</span>
        <span class="n">ash_percentile</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.90</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">use_react</span><span class="o">=</span><span class="n">use_react</span><span class="p">,</span>
            <span class="n">use_scale</span><span class="o">=</span><span class="n">use_scale</span><span class="p">,</span>
            <span class="n">use_ash</span><span class="o">=</span><span class="n">use_ash</span><span class="p">,</span>
            <span class="n">react_quantile</span><span class="o">=</span><span class="n">react_quantile</span><span class="p">,</span>
            <span class="n">scale_percentile</span><span class="o">=</span><span class="n">scale_percentile</span><span class="p">,</span>
            <span class="n">ash_percentile</span><span class="o">=</span><span class="n">ash_percentile</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_activation</span> <span class="o">=</span> <span class="n">output_activation</span>

    <span class="k">def</span> <span class="nf">_score_tensor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">:</span> <span class="n">TensorType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes an OOD score for input samples &quot;inputs&quot; based on</span>
<span class="sd">        the distance to nearest neighbors in the feature space of self.model</span>

<span class="sd">        Args:</span>
<span class="sd">            inputs: input samples to score</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple[np.ndarray]: scores, logits</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">_</span><span class="p">,</span> <span class="n">logits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_extractor</span><span class="o">.</span><span class="n">predict_tensor</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_activation</span> <span class="o">==</span> <span class="s2">&quot;softmax&quot;</span><span class="p">:</span>
            <span class="n">logits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">softmax</span><span class="p">(</span><span class="n">logits</span><span class="p">)</span>
        <span class="n">logits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">convert_to_numpy</span><span class="p">(</span><span class="n">logits</span><span class="p">)</span>
        <span class="n">scores</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">logits</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">scores</span>

    <span class="k">def</span> <span class="nf">_fit_to_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fit_dataset</span><span class="p">:</span> <span class="n">DatasetType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fits the OOD detector to fit_dataset.</span>

<span class="sd">        Args:</span>
<span class="sd">            fit_dataset: dataset to fit the OOD detector on</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">requires_to_fit_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Whether an OOD detector needs a `fit_dataset` argument in the fit function.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if `fit_dataset` is required else False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">requires_internal_features</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Whether an OOD detector acts on internal model features.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if the detector perform computations on an intermediate layer</span>
<span class="sd">            else False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">False</span>
</code></pre></div></td></tr></table></div>
        </details>

  

  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h3 id="oodeel.methods.mls.MLS.requires_internal_features" class="doc doc-heading">
<code class="highlight language-python"><span class="n">requires_internal_features</span><span class="p">:</span> <span class="nb">bool</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

<a href="#oodeel.methods.mls.MLS.requires_internal_features" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Whether an OOD detector acts on internal model features.</p>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>bool</code></td>          <td>
                <code>bool</code>
          </td>
          <td><p>True if the detector perform computations on an intermediate layer</p></td>
        </tr>
        <tr>
<td></td>          <td>
                <code>bool</code>
          </td>
          <td><p>else False.</p></td>
        </tr>
    </tbody>
  </table>
  </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="oodeel.methods.mls.MLS.requires_to_fit_dataset" class="doc doc-heading">
<code class="highlight language-python"><span class="n">requires_to_fit_dataset</span><span class="p">:</span> <span class="nb">bool</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

<a href="#oodeel.methods.mls.MLS.requires_to_fit_dataset" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Whether an OOD detector needs a <code>fit_dataset</code> argument in the fit function.</p>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>bool</code></td>          <td>
                <code>bool</code>
          </td>
          <td><p>True if <code>fit_dataset</code> is required else False.</p></td>
        </tr>
    </tbody>
  </table>
  </div>

</div>



<div class="doc doc-object doc-function">



<h3 id="oodeel.methods.mls.MLS._fit_to_dataset" class="doc doc-heading">
<code class="highlight language-python"><span class="n">_fit_to_dataset</span><span class="p">(</span><span class="n">fit_dataset</span><span class="p">)</span></code>

<a href="#oodeel.methods.mls.MLS._fit_to_dataset" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Fits the OOD detector to fit_dataset.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>fit_dataset</code></td>
          <td>
                <code><span title="oodeel.types.DatasetType">DatasetType</span></code>
          </td>
          <td><p>dataset to fit the OOD detector on</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>oodeel/methods/mls.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">91</span>
<span class="normal">92</span>
<span class="normal">93</span>
<span class="normal">94</span>
<span class="normal">95</span>
<span class="normal">96</span>
<span class="normal">97</span>
<span class="normal">98</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">_fit_to_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fit_dataset</span><span class="p">:</span> <span class="n">DatasetType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fits the OOD detector to fit_dataset.</span>

<span class="sd">    Args:</span>
<span class="sd">        fit_dataset: dataset to fit the OOD detector on</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h3 id="oodeel.methods.mls.MLS._score_tensor" class="doc doc-heading">
<code class="highlight language-python"><span class="n">_score_tensor</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span></code>

<a href="#oodeel.methods.mls.MLS._score_tensor" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Computes an OOD score for input samples "inputs" based on
the distance to nearest neighbors in the feature space of self.model</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>inputs</code></td>
          <td>
                <code><span title="oodeel.types.TensorType">TensorType</span></code>
          </td>
          <td><p>input samples to score</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code><span title="oodeel.types.Tuple">Tuple</span>[<span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span>]</code>
          </td>
          <td><p>Tuple[np.ndarray]: scores, logits</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>oodeel/methods/mls.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">72</span>
<span class="normal">73</span>
<span class="normal">74</span>
<span class="normal">75</span>
<span class="normal">76</span>
<span class="normal">77</span>
<span class="normal">78</span>
<span class="normal">79</span>
<span class="normal">80</span>
<span class="normal">81</span>
<span class="normal">82</span>
<span class="normal">83</span>
<span class="normal">84</span>
<span class="normal">85</span>
<span class="normal">86</span>
<span class="normal">87</span>
<span class="normal">88</span>
<span class="normal">89</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">_score_tensor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">:</span> <span class="n">TensorType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes an OOD score for input samples &quot;inputs&quot; based on</span>
<span class="sd">    the distance to nearest neighbors in the feature space of self.model</span>

<span class="sd">    Args:</span>
<span class="sd">        inputs: input samples to score</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple[np.ndarray]: scores, logits</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_</span><span class="p">,</span> <span class="n">logits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_extractor</span><span class="o">.</span><span class="n">predict_tensor</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_activation</span> <span class="o">==</span> <span class="s2">&quot;softmax&quot;</span><span class="p">:</span>
        <span class="n">logits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">softmax</span><span class="p">(</span><span class="n">logits</span><span class="p">)</span>
    <span class="n">logits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">convert_to_numpy</span><span class="p">(</span><span class="n">logits</span><span class="p">)</span>
    <span class="n">scores</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">logits</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">scores</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>



  </div>

  </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="oodeel.methods.Mahalanobis" class="doc doc-heading">
        <code>Mahalanobis</code>


<a href="#oodeel.methods.Mahalanobis" class="headerlink" title="Permanent link">&para;</a></h2>


  <div class="doc doc-contents ">
      <p class="doc doc-class-bases">
        Bases: <code><a class="autorefs autorefs-internal" title="oodeel.methods.base.OODBaseDetector" href="#oodeel.methods.base.OODBaseDetector">OODBaseDetector</a></code></p>

  
      <p>"A Simple Unified Framework for Detecting Out-of-Distribution Samples and
Adversarial Attacks"
https://arxiv.org/abs/1807.03888</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>eps</code></td>
          <td>
                <code>float</code>
          </td>
          <td><p>magnitude for gradient based input perturbation.
Defaults to 0.02.</p></td>
          <td>
                <code>0.002</code>
          </td>
        </tr>
    </tbody>
  </table>


        <details class="quote">
          <summary>Source code in <code>oodeel/methods/mahalanobis.py</code></summary>
          <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 31</span>
<span class="normal"> 32</span>
<span class="normal"> 33</span>
<span class="normal"> 34</span>
<span class="normal"> 35</span>
<span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">Mahalanobis</span><span class="p">(</span><span class="n">OODBaseDetector</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &quot;A Simple Unified Framework for Detecting Out-of-Distribution Samples and</span>
<span class="sd">    Adversarial Attacks&quot;</span>
<span class="sd">    https://arxiv.org/abs/1807.03888</span>

<span class="sd">    Args:</span>
<span class="sd">        eps (float): magnitude for gradient based input perturbation.</span>
<span class="sd">            Defaults to 0.02.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">eps</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.002</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Mahalanobis</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eps</span> <span class="o">=</span> <span class="n">eps</span>

    <span class="k">def</span> <span class="nf">_fit_to_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fit_dataset</span><span class="p">:</span> <span class="n">DatasetType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructs the mean covariance matrix from ID data &quot;fit_dataset&quot;, whose</span>
<span class="sd">        pseudo-inverse will be used for mahalanobis distance computation.</span>

<span class="sd">        Args:</span>
<span class="sd">            fit_dataset (Union[TensorType, DatasetType]): input dataset (ID)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># extract features and labels</span>
        <span class="n">features</span><span class="p">,</span> <span class="n">infos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_extractor</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">fit_dataset</span><span class="p">,</span> <span class="n">detach</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">infos</span><span class="p">[</span><span class="s2">&quot;labels&quot;</span><span class="p">]</span>

        <span class="c1"># unique sorted classes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_classes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">convert_to_numpy</span><span class="p">(</span><span class="n">labels</span><span class="p">)))</span>

        <span class="c1"># compute mus and covs</span>
        <span class="n">mus</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">mean_cov</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_classes</span><span class="p">:</span>
            <span class="n">indexes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span>
            <span class="n">_features_cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">features</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">indexes</span><span class="p">])</span>
            <span class="n">mus</span><span class="p">[</span><span class="bp">cls</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">_features_cls</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">_zero_f_cls</span> <span class="o">=</span> <span class="n">_features_cls</span> <span class="o">-</span> <span class="n">mus</span><span class="p">[</span><span class="bp">cls</span><span class="p">]</span>
            <span class="n">cov_cls</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">t</span><span class="p">(</span><span class="n">_zero_f_cls</span><span class="p">),</span> <span class="n">_zero_f_cls</span><span class="p">)</span>
                <span class="o">/</span> <span class="n">_zero_f_cls</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">mean_cov</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">mean_cov</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">_features_cls</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">features</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">*</span> <span class="n">cov_cls</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mean_cov</span> <span class="o">+=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">_features_cls</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">features</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">*</span> <span class="n">cov_cls</span>

        <span class="c1"># pseudo-inverse of the mean covariance matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pinv_cov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">mean_cov</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mus</span> <span class="o">=</span> <span class="n">mus</span>

    <span class="k">def</span> <span class="nf">_score_tensor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">:</span> <span class="n">TensorType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes an OOD score for input samples &quot;inputs&quot; based on the mahalanobis</span>
<span class="sd">        distance with respect to the closest class-conditional Gaussian distribution.</span>

<span class="sd">        Args:</span>
<span class="sd">            inputs (TensorType): input samples</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple[np.ndarray]: scores, logits</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># input preprocessing (perturbation)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">inputs_p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_perturbation</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">inputs_p</span> <span class="o">=</span> <span class="n">inputs</span>

        <span class="c1"># mahalanobis score on perturbed inputs</span>
        <span class="n">features_p</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_extractor</span><span class="o">.</span><span class="n">predict_tensor</span><span class="p">(</span><span class="n">inputs_p</span><span class="p">)</span>
        <span class="n">features_p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">features_p</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">gaussian_score_p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mahalanobis_score</span><span class="p">(</span><span class="n">features_p</span><span class="p">)</span>

        <span class="c1"># take the highest score for each sample</span>
        <span class="n">gaussian_score_p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">gaussian_score_p</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">convert_to_numpy</span><span class="p">(</span><span class="n">gaussian_score_p</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_input_perturbation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">:</span> <span class="n">TensorType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TensorType</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply small perturbation on inputs to make the in- and out- distribution</span>
<span class="sd">        samples more separable.</span>
<span class="sd">        See original paper for more information (section 2.2)</span>
<span class="sd">        https://arxiv.org/abs/1807.03888</span>

<span class="sd">        Args:</span>
<span class="sd">            inputs (TensorType): input samples</span>

<span class="sd">        Returns:</span>
<span class="sd">            TensorType: Perturbed inputs</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">__loss_fn</span><span class="p">(</span><span class="n">inputs</span><span class="p">:</span> <span class="n">TensorType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TensorType</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Loss function for the input perturbation.</span>

<span class="sd">            Args:</span>
<span class="sd">                inputs (TensorType): input samples</span>

<span class="sd">            Returns:</span>
<span class="sd">                TensorType: loss value</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="c1"># extract features</span>
            <span class="n">out_features</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_extractor</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">detach</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">out_features</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">out_features</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="c1"># get mahalanobis score for the class maximizing it</span>
            <span class="n">gaussian_score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mahalanobis_score</span><span class="p">(</span><span class="n">out_features</span><span class="p">)</span>
            <span class="n">log_probs_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">gaussian_score</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="o">-</span><span class="n">log_probs_f</span><span class="p">)</span>

        <span class="c1"># compute gradient</span>
        <span class="n">gradient</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">__loss_fn</span><span class="p">,</span> <span class="n">inputs</span><span class="p">)</span>
        <span class="n">gradient</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">gradient</span><span class="p">)</span>

        <span class="n">inputs_p</span> <span class="o">=</span> <span class="n">inputs</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span> <span class="o">*</span> <span class="n">gradient</span>
        <span class="k">return</span> <span class="n">inputs_p</span>

    <span class="k">def</span> <span class="nf">_mahalanobis_score</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out_features</span><span class="p">:</span> <span class="n">TensorType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TensorType</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Mahalanobis distance-based confidence score. For each test sample, it computes</span>
<span class="sd">        the log of the probability densities of some observations (assuming a</span>
<span class="sd">        normal distribution) using the mahalanobis distance with respect to every</span>
<span class="sd">        class-conditional distributions.</span>

<span class="sd">        Args:</span>
<span class="sd">            out_features (TensorType): test samples features</span>

<span class="sd">        Returns:</span>
<span class="sd">            TensorType: confidence scores (conditionally to each class)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">gaussian_scores</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="c1"># compute scores conditionally to each class</span>
        <span class="k">for</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_classes</span><span class="p">:</span>
            <span class="c1"># center features wrt class-cond dist.</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mus</span><span class="p">[</span><span class="bp">cls</span><span class="p">]</span>
            <span class="n">zero_f</span> <span class="o">=</span> <span class="n">out_features</span> <span class="o">-</span> <span class="n">mu</span>
            <span class="c1"># gaussian log prob density (mahalanobis)</span>
            <span class="n">log_probs_f</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">zero_f</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pinv_cov</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">t</span><span class="p">(</span><span class="n">zero_f</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="n">gaussian_scores</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">log_probs_f</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="c1"># concatenate scores</span>
        <span class="n">gaussian_score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="n">gaussian_scores</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">gaussian_score</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">requires_to_fit_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Whether an OOD detector needs a `fit_dataset` argument in the fit function.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if `fit_dataset` is required else False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">requires_internal_features</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Whether an OOD detector acts on internal model features.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if the detector perform computations on an intermediate layer</span>
<span class="sd">            else False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">True</span>
</code></pre></div></td></tr></table></div>
        </details>

  

  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h3 id="oodeel.methods.mahalanobis.Mahalanobis.requires_internal_features" class="doc doc-heading">
<code class="highlight language-python"><span class="n">requires_internal_features</span><span class="p">:</span> <span class="nb">bool</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

<a href="#oodeel.methods.mahalanobis.Mahalanobis.requires_internal_features" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Whether an OOD detector acts on internal model features.</p>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>bool</code></td>          <td>
                <code>bool</code>
          </td>
          <td><p>True if the detector perform computations on an intermediate layer</p></td>
        </tr>
        <tr>
<td></td>          <td>
                <code>bool</code>
          </td>
          <td><p>else False.</p></td>
        </tr>
    </tbody>
  </table>
  </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="oodeel.methods.mahalanobis.Mahalanobis.requires_to_fit_dataset" class="doc doc-heading">
<code class="highlight language-python"><span class="n">requires_to_fit_dataset</span><span class="p">:</span> <span class="nb">bool</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

<a href="#oodeel.methods.mahalanobis.Mahalanobis.requires_to_fit_dataset" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Whether an OOD detector needs a <code>fit_dataset</code> argument in the fit function.</p>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>bool</code></td>          <td>
                <code>bool</code>
          </td>
          <td><p>True if <code>fit_dataset</code> is required else False.</p></td>
        </tr>
    </tbody>
  </table>
  </div>

</div>



<div class="doc doc-object doc-function">



<h3 id="oodeel.methods.mahalanobis.Mahalanobis._fit_to_dataset" class="doc doc-heading">
<code class="highlight language-python"><span class="n">_fit_to_dataset</span><span class="p">(</span><span class="n">fit_dataset</span><span class="p">)</span></code>

<a href="#oodeel.methods.mahalanobis.Mahalanobis._fit_to_dataset" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Constructs the mean covariance matrix from ID data "fit_dataset", whose
pseudo-inverse will be used for mahalanobis distance computation.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>fit_dataset</code></td>
          <td>
                <code>Union[<span title="oodeel.types.TensorType">TensorType</span>, <span title="oodeel.types.DatasetType">DatasetType</span>]</code>
          </td>
          <td><p>input dataset (ID)</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>oodeel/methods/mahalanobis.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span>
<span class="normal">53</span>
<span class="normal">54</span>
<span class="normal">55</span>
<span class="normal">56</span>
<span class="normal">57</span>
<span class="normal">58</span>
<span class="normal">59</span>
<span class="normal">60</span>
<span class="normal">61</span>
<span class="normal">62</span>
<span class="normal">63</span>
<span class="normal">64</span>
<span class="normal">65</span>
<span class="normal">66</span>
<span class="normal">67</span>
<span class="normal">68</span>
<span class="normal">69</span>
<span class="normal">70</span>
<span class="normal">71</span>
<span class="normal">72</span>
<span class="normal">73</span>
<span class="normal">74</span>
<span class="normal">75</span>
<span class="normal">76</span>
<span class="normal">77</span>
<span class="normal">78</span>
<span class="normal">79</span>
<span class="normal">80</span>
<span class="normal">81</span>
<span class="normal">82</span>
<span class="normal">83</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">_fit_to_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fit_dataset</span><span class="p">:</span> <span class="n">DatasetType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Constructs the mean covariance matrix from ID data &quot;fit_dataset&quot;, whose</span>
<span class="sd">    pseudo-inverse will be used for mahalanobis distance computation.</span>

<span class="sd">    Args:</span>
<span class="sd">        fit_dataset (Union[TensorType, DatasetType]): input dataset (ID)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># extract features and labels</span>
    <span class="n">features</span><span class="p">,</span> <span class="n">infos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_extractor</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">fit_dataset</span><span class="p">,</span> <span class="n">detach</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="n">infos</span><span class="p">[</span><span class="s2">&quot;labels&quot;</span><span class="p">]</span>

    <span class="c1"># unique sorted classes</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_classes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">convert_to_numpy</span><span class="p">(</span><span class="n">labels</span><span class="p">)))</span>

    <span class="c1"># compute mus and covs</span>
    <span class="n">mus</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">mean_cov</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_classes</span><span class="p">:</span>
        <span class="n">indexes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span>
        <span class="n">_features_cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">features</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">indexes</span><span class="p">])</span>
        <span class="n">mus</span><span class="p">[</span><span class="bp">cls</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">_features_cls</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">_zero_f_cls</span> <span class="o">=</span> <span class="n">_features_cls</span> <span class="o">-</span> <span class="n">mus</span><span class="p">[</span><span class="bp">cls</span><span class="p">]</span>
        <span class="n">cov_cls</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">t</span><span class="p">(</span><span class="n">_zero_f_cls</span><span class="p">),</span> <span class="n">_zero_f_cls</span><span class="p">)</span>
            <span class="o">/</span> <span class="n">_zero_f_cls</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">mean_cov</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mean_cov</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">_features_cls</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">features</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">*</span> <span class="n">cov_cls</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mean_cov</span> <span class="o">+=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">_features_cls</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">features</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">*</span> <span class="n">cov_cls</span>

    <span class="c1"># pseudo-inverse of the mean covariance matrix</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_pinv_cov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">mean_cov</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_mus</span> <span class="o">=</span> <span class="n">mus</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h3 id="oodeel.methods.mahalanobis.Mahalanobis._input_perturbation" class="doc doc-heading">
<code class="highlight language-python"><span class="n">_input_perturbation</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span></code>

<a href="#oodeel.methods.mahalanobis.Mahalanobis._input_perturbation" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Apply small perturbation on inputs to make the in- and out- distribution
samples more separable.
See original paper for more information (section 2.2)
https://arxiv.org/abs/1807.03888</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>inputs</code></td>
          <td>
                <code><span title="oodeel.types.TensorType">TensorType</span></code>
          </td>
          <td><p>input samples</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>TensorType</code></td>          <td>
                <code><span title="oodeel.types.TensorType">TensorType</span></code>
          </td>
          <td><p>Perturbed inputs</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>oodeel/methods/mahalanobis.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">_input_perturbation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">:</span> <span class="n">TensorType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TensorType</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply small perturbation on inputs to make the in- and out- distribution</span>
<span class="sd">    samples more separable.</span>
<span class="sd">    See original paper for more information (section 2.2)</span>
<span class="sd">    https://arxiv.org/abs/1807.03888</span>

<span class="sd">    Args:</span>
<span class="sd">        inputs (TensorType): input samples</span>

<span class="sd">    Returns:</span>
<span class="sd">        TensorType: Perturbed inputs</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__loss_fn</span><span class="p">(</span><span class="n">inputs</span><span class="p">:</span> <span class="n">TensorType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TensorType</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loss function for the input perturbation.</span>

<span class="sd">        Args:</span>
<span class="sd">            inputs (TensorType): input samples</span>

<span class="sd">        Returns:</span>
<span class="sd">            TensorType: loss value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># extract features</span>
        <span class="n">out_features</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_extractor</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">detach</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">out_features</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">out_features</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="c1"># get mahalanobis score for the class maximizing it</span>
        <span class="n">gaussian_score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mahalanobis_score</span><span class="p">(</span><span class="n">out_features</span><span class="p">)</span>
        <span class="n">log_probs_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">gaussian_score</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="o">-</span><span class="n">log_probs_f</span><span class="p">)</span>

    <span class="c1"># compute gradient</span>
    <span class="n">gradient</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">__loss_fn</span><span class="p">,</span> <span class="n">inputs</span><span class="p">)</span>
    <span class="n">gradient</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">gradient</span><span class="p">)</span>

    <span class="n">inputs_p</span> <span class="o">=</span> <span class="n">inputs</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span> <span class="o">*</span> <span class="n">gradient</span>
    <span class="k">return</span> <span class="n">inputs_p</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h3 id="oodeel.methods.mahalanobis.Mahalanobis._mahalanobis_score" class="doc doc-heading">
<code class="highlight language-python"><span class="n">_mahalanobis_score</span><span class="p">(</span><span class="n">out_features</span><span class="p">)</span></code>

<a href="#oodeel.methods.mahalanobis.Mahalanobis._mahalanobis_score" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Mahalanobis distance-based confidence score. For each test sample, it computes
the log of the probability densities of some observations (assuming a
normal distribution) using the mahalanobis distance with respect to every
class-conditional distributions.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>out_features</code></td>
          <td>
                <code><span title="oodeel.types.TensorType">TensorType</span></code>
          </td>
          <td><p>test samples features</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>TensorType</code></td>          <td>
                <code><span title="oodeel.types.TensorType">TensorType</span></code>
          </td>
          <td><p>confidence scores (conditionally to each class)</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>oodeel/methods/mahalanobis.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">_mahalanobis_score</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out_features</span><span class="p">:</span> <span class="n">TensorType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TensorType</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mahalanobis distance-based confidence score. For each test sample, it computes</span>
<span class="sd">    the log of the probability densities of some observations (assuming a</span>
<span class="sd">    normal distribution) using the mahalanobis distance with respect to every</span>
<span class="sd">    class-conditional distributions.</span>

<span class="sd">    Args:</span>
<span class="sd">        out_features (TensorType): test samples features</span>

<span class="sd">    Returns:</span>
<span class="sd">        TensorType: confidence scores (conditionally to each class)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">gaussian_scores</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="c1"># compute scores conditionally to each class</span>
    <span class="k">for</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_classes</span><span class="p">:</span>
        <span class="c1"># center features wrt class-cond dist.</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mus</span><span class="p">[</span><span class="bp">cls</span><span class="p">]</span>
        <span class="n">zero_f</span> <span class="o">=</span> <span class="n">out_features</span> <span class="o">-</span> <span class="n">mu</span>
        <span class="c1"># gaussian log prob density (mahalanobis)</span>
        <span class="n">log_probs_f</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">zero_f</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pinv_cov</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">t</span><span class="p">(</span><span class="n">zero_f</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="n">gaussian_scores</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">log_probs_f</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
    <span class="c1"># concatenate scores</span>
    <span class="n">gaussian_score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="n">gaussian_scores</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">gaussian_score</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h3 id="oodeel.methods.mahalanobis.Mahalanobis._score_tensor" class="doc doc-heading">
<code class="highlight language-python"><span class="n">_score_tensor</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span></code>

<a href="#oodeel.methods.mahalanobis.Mahalanobis._score_tensor" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Computes an OOD score for input samples "inputs" based on the mahalanobis
distance with respect to the closest class-conditional Gaussian distribution.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>inputs</code></td>
          <td>
                <code><span title="oodeel.types.TensorType">TensorType</span></code>
          </td>
          <td><p>input samples</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code><span title="oodeel.types.Tuple">Tuple</span>[<span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span>]</code>
          </td>
          <td><p>Tuple[np.ndarray]: scores, logits</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>oodeel/methods/mahalanobis.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">_score_tensor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">:</span> <span class="n">TensorType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes an OOD score for input samples &quot;inputs&quot; based on the mahalanobis</span>
<span class="sd">    distance with respect to the closest class-conditional Gaussian distribution.</span>

<span class="sd">    Args:</span>
<span class="sd">        inputs (TensorType): input samples</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple[np.ndarray]: scores, logits</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># input preprocessing (perturbation)</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">inputs_p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_perturbation</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">inputs_p</span> <span class="o">=</span> <span class="n">inputs</span>

    <span class="c1"># mahalanobis score on perturbed inputs</span>
    <span class="n">features_p</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_extractor</span><span class="o">.</span><span class="n">predict_tensor</span><span class="p">(</span><span class="n">inputs_p</span><span class="p">)</span>
    <span class="n">features_p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">features_p</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">gaussian_score_p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mahalanobis_score</span><span class="p">(</span><span class="n">features_p</span><span class="p">)</span>

    <span class="c1"># take the highest score for each sample</span>
    <span class="n">gaussian_score_p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">gaussian_score_p</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">convert_to_numpy</span><span class="p">(</span><span class="n">gaussian_score_p</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>



  </div>

  </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="oodeel.methods.ODIN" class="doc doc-heading">
        <code>ODIN</code>


<a href="#oodeel.methods.ODIN" class="headerlink" title="Permanent link">&para;</a></h2>


  <div class="doc doc-contents ">
      <p class="doc doc-class-bases">
        Bases: <code><a class="autorefs autorefs-internal" title="oodeel.methods.base.OODBaseDetector" href="#oodeel.methods.base.OODBaseDetector">OODBaseDetector</a></code></p>

  
      <p>"Enhancing The Reliability of Out-of-distribution Image Detection
in Neural Networks"
http://arxiv.org/abs/1706.02690</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>temperature</code></td>
          <td>
                <code>float</code>
          </td>
          <td><p>Temperature parameter. Defaults to 1000.</p></td>
          <td>
                <code>1000</code>
          </td>
        </tr>
        <tr>
          <td><code>noise</code></td>
          <td>
                <code>float</code>
          </td>
          <td><p>Perturbation noise. Defaults to 0.014.</p></td>
          <td>
                <code>0.014</code>
          </td>
        </tr>
        <tr>
          <td><code>use_react</code></td>
          <td>
                <code>bool</code>
          </td>
          <td><p>if true, apply ReAct method by clipping penultimate
activations under a threshold value.</p></td>
          <td>
                <code>False</code>
          </td>
        </tr>
        <tr>
          <td><code>react_quantile</code></td>
          <td>
                <code>Optional[float]</code>
          </td>
          <td><p>q value in the range [0, 1] used to compute
the react clipping threshold defined as the q-th quantile penultimate layer
activations. Defaults to 0.8.</p></td>
          <td>
                <code>0.8</code>
          </td>
        </tr>
    </tbody>
  </table>


        <details class="quote">
          <summary>Source code in <code>oodeel/methods/odin.py</code></summary>
          <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 31</span>
<span class="normal"> 32</span>
<span class="normal"> 33</span>
<span class="normal"> 34</span>
<span class="normal"> 35</span>
<span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">ODIN</span><span class="p">(</span><span class="n">OODBaseDetector</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; &quot;Enhancing The Reliability of Out-of-distribution Image Detection</span>
<span class="sd">    in Neural Networks&quot;</span>
<span class="sd">    http://arxiv.org/abs/1706.02690</span>

<span class="sd">    Args:</span>
<span class="sd">        temperature (float, optional): Temperature parameter. Defaults to 1000.</span>
<span class="sd">        noise (float, optional): Perturbation noise. Defaults to 0.014.</span>
<span class="sd">        use_react (bool): if true, apply ReAct method by clipping penultimate</span>
<span class="sd">            activations under a threshold value.</span>
<span class="sd">        react_quantile (Optional[float]): q value in the range [0, 1] used to compute</span>
<span class="sd">            the react clipping threshold defined as the q-th quantile penultimate layer</span>
<span class="sd">            activations. Defaults to 0.8.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">temperature</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
        <span class="n">noise</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.014</span><span class="p">,</span>
        <span class="n">use_react</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">use_scale</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">use_ash</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">react_quantile</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">,</span>
        <span class="n">scale_percentile</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.85</span><span class="p">,</span>
        <span class="n">ash_percentile</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.90</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">temperature</span> <span class="o">=</span> <span class="n">temperature</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">use_react</span><span class="o">=</span><span class="n">use_react</span><span class="p">,</span>
            <span class="n">use_scale</span><span class="o">=</span><span class="n">use_scale</span><span class="p">,</span>
            <span class="n">use_ash</span><span class="o">=</span><span class="n">use_ash</span><span class="p">,</span>
            <span class="n">react_quantile</span><span class="o">=</span><span class="n">react_quantile</span><span class="p">,</span>
            <span class="n">scale_percentile</span><span class="o">=</span><span class="n">scale_percentile</span><span class="p">,</span>
            <span class="n">ash_percentile</span><span class="o">=</span><span class="n">ash_percentile</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">noise</span> <span class="o">=</span> <span class="n">noise</span>

    <span class="k">def</span> <span class="nf">_score_tensor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">:</span> <span class="n">TensorType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes an OOD score for input samples &quot;inputs&quot; based on</span>
<span class="sd">        the distance to nearest neighbors in the feature space of self.model</span>

<span class="sd">        Args:</span>
<span class="sd">            inputs (TensorType): input samples to score</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple[np.ndarray]: scores, logits</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_extractor</span><span class="o">.</span><span class="n">backend</span> <span class="o">==</span> <span class="s2">&quot;torch&quot;</span><span class="p">:</span>
            <span class="n">inputs</span> <span class="o">=</span> <span class="n">inputs</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">feature_extractor</span><span class="o">.</span><span class="n">_device</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_perturbation</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">logits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_extractor</span><span class="o">.</span><span class="n">predict_tensor</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">logits_s</span> <span class="o">=</span> <span class="n">logits</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">temperature</span>
        <span class="n">probits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">softmax</span><span class="p">(</span><span class="n">logits_s</span><span class="p">)</span>
        <span class="n">probits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">convert_to_numpy</span><span class="p">(</span><span class="n">probits</span><span class="p">)</span>
        <span class="n">scores</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">probits</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">scores</span>

    <span class="k">def</span> <span class="nf">input_perturbation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">:</span> <span class="n">TensorType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TensorType</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply a small perturbation over inputs to increase their softmax score.</span>
<span class="sd">        See ODIN paper for more information (section 3):</span>
<span class="sd">        http://arxiv.org/abs/1706.02690</span>

<span class="sd">        Args:</span>
<span class="sd">            inputs (TensorType): input samples to score</span>

<span class="sd">        Returns:</span>
<span class="sd">            TensorType: Perturbed inputs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">preds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_extractor</span><span class="o">.</span><span class="n">model</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
        <span class="n">outputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">preds</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">gradients</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_temperature_loss</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="p">)</span>
        <span class="n">inputs_p</span> <span class="o">=</span> <span class="n">inputs</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">gradients</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">inputs_p</span>

    <span class="k">def</span> <span class="nf">_temperature_loss</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">:</span> <span class="n">TensorType</span><span class="p">,</span> <span class="n">labels</span><span class="p">:</span> <span class="n">TensorType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TensorType</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the tempered cross-entropy loss.</span>

<span class="sd">        Args:</span>
<span class="sd">            inputs (TensorType): the inputs of the model.</span>
<span class="sd">            labels (TensorType): the labels to fit on.</span>

<span class="sd">        Returns:</span>
<span class="sd">            TensorType: the cross-entropy loss.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">preds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_extractor</span><span class="o">.</span><span class="n">model</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">temperature</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">CrossEntropyLoss</span><span class="p">(</span><span class="n">reduction</span><span class="o">=</span><span class="s2">&quot;sum&quot;</span><span class="p">)(</span><span class="n">inputs</span><span class="o">=</span><span class="n">preds</span><span class="p">,</span> <span class="n">targets</span><span class="o">=</span><span class="n">labels</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">loss</span>

    <span class="k">def</span> <span class="nf">_fit_to_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fit_dataset</span><span class="p">:</span> <span class="n">DatasetType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fits the OOD detector to fit_dataset.</span>

<span class="sd">        Args:</span>
<span class="sd">            fit_dataset: dataset to fit the OOD detector on</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">requires_to_fit_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Whether an OOD detector needs a `fit_dataset` argument in the fit function.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if `fit_dataset` is required else False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">requires_internal_features</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Whether an OOD detector acts on internal model features.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if the detector perform computations on an intermediate layer</span>
<span class="sd">            else False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">False</span>
</code></pre></div></td></tr></table></div>
        </details>

  

  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h3 id="oodeel.methods.odin.ODIN.requires_internal_features" class="doc doc-heading">
<code class="highlight language-python"><span class="n">requires_internal_features</span><span class="p">:</span> <span class="nb">bool</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

<a href="#oodeel.methods.odin.ODIN.requires_internal_features" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Whether an OOD detector acts on internal model features.</p>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>bool</code></td>          <td>
                <code>bool</code>
          </td>
          <td><p>True if the detector perform computations on an intermediate layer</p></td>
        </tr>
        <tr>
<td></td>          <td>
                <code>bool</code>
          </td>
          <td><p>else False.</p></td>
        </tr>
    </tbody>
  </table>
  </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="oodeel.methods.odin.ODIN.requires_to_fit_dataset" class="doc doc-heading">
<code class="highlight language-python"><span class="n">requires_to_fit_dataset</span><span class="p">:</span> <span class="nb">bool</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

<a href="#oodeel.methods.odin.ODIN.requires_to_fit_dataset" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Whether an OOD detector needs a <code>fit_dataset</code> argument in the fit function.</p>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>bool</code></td>          <td>
                <code>bool</code>
          </td>
          <td><p>True if <code>fit_dataset</code> is required else False.</p></td>
        </tr>
    </tbody>
  </table>
  </div>

</div>



<div class="doc doc-object doc-function">



<h3 id="oodeel.methods.odin.ODIN._fit_to_dataset" class="doc doc-heading">
<code class="highlight language-python"><span class="n">_fit_to_dataset</span><span class="p">(</span><span class="n">fit_dataset</span><span class="p">)</span></code>

<a href="#oodeel.methods.odin.ODIN._fit_to_dataset" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Fits the OOD detector to fit_dataset.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>fit_dataset</code></td>
          <td>
                <code><span title="oodeel.types.DatasetType">DatasetType</span></code>
          </td>
          <td><p>dataset to fit the OOD detector on</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>oodeel/methods/odin.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">_fit_to_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fit_dataset</span><span class="p">:</span> <span class="n">DatasetType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fits the OOD detector to fit_dataset.</span>

<span class="sd">    Args:</span>
<span class="sd">        fit_dataset: dataset to fit the OOD detector on</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h3 id="oodeel.methods.odin.ODIN._score_tensor" class="doc doc-heading">
<code class="highlight language-python"><span class="n">_score_tensor</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span></code>

<a href="#oodeel.methods.odin.ODIN._score_tensor" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Computes an OOD score for input samples "inputs" based on
the distance to nearest neighbors in the feature space of self.model</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>inputs</code></td>
          <td>
                <code><span title="oodeel.types.TensorType">TensorType</span></code>
          </td>
          <td><p>input samples to score</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code><span title="oodeel.types.Tuple">Tuple</span>[<span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span>]</code>
          </td>
          <td><p>Tuple[np.ndarray]: scores, logits</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>oodeel/methods/odin.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">68</span>
<span class="normal">69</span>
<span class="normal">70</span>
<span class="normal">71</span>
<span class="normal">72</span>
<span class="normal">73</span>
<span class="normal">74</span>
<span class="normal">75</span>
<span class="normal">76</span>
<span class="normal">77</span>
<span class="normal">78</span>
<span class="normal">79</span>
<span class="normal">80</span>
<span class="normal">81</span>
<span class="normal">82</span>
<span class="normal">83</span>
<span class="normal">84</span>
<span class="normal">85</span>
<span class="normal">86</span>
<span class="normal">87</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">_score_tensor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">:</span> <span class="n">TensorType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes an OOD score for input samples &quot;inputs&quot; based on</span>
<span class="sd">    the distance to nearest neighbors in the feature space of self.model</span>

<span class="sd">    Args:</span>
<span class="sd">        inputs (TensorType): input samples to score</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple[np.ndarray]: scores, logits</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_extractor</span><span class="o">.</span><span class="n">backend</span> <span class="o">==</span> <span class="s2">&quot;torch&quot;</span><span class="p">:</span>
        <span class="n">inputs</span> <span class="o">=</span> <span class="n">inputs</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">feature_extractor</span><span class="o">.</span><span class="n">_device</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_perturbation</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">logits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_extractor</span><span class="o">.</span><span class="n">predict_tensor</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">logits_s</span> <span class="o">=</span> <span class="n">logits</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">temperature</span>
    <span class="n">probits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">softmax</span><span class="p">(</span><span class="n">logits_s</span><span class="p">)</span>
    <span class="n">probits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">convert_to_numpy</span><span class="p">(</span><span class="n">probits</span><span class="p">)</span>
    <span class="n">scores</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">probits</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">scores</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h3 id="oodeel.methods.odin.ODIN._temperature_loss" class="doc doc-heading">
<code class="highlight language-python"><span class="n">_temperature_loss</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span></code>

<a href="#oodeel.methods.odin.ODIN._temperature_loss" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Compute the tempered cross-entropy loss.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>inputs</code></td>
          <td>
                <code><span title="oodeel.types.TensorType">TensorType</span></code>
          </td>
          <td><p>the inputs of the model.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>labels</code></td>
          <td>
                <code><span title="oodeel.types.TensorType">TensorType</span></code>
          </td>
          <td><p>the labels to fit on.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>TensorType</code></td>          <td>
                <code><span title="oodeel.types.TensorType">TensorType</span></code>
          </td>
          <td><p>the cross-entropy loss.</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>oodeel/methods/odin.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">_temperature_loss</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">:</span> <span class="n">TensorType</span><span class="p">,</span> <span class="n">labels</span><span class="p">:</span> <span class="n">TensorType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TensorType</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the tempered cross-entropy loss.</span>

<span class="sd">    Args:</span>
<span class="sd">        inputs (TensorType): the inputs of the model.</span>
<span class="sd">        labels (TensorType): the labels to fit on.</span>

<span class="sd">    Returns:</span>
<span class="sd">        TensorType: the cross-entropy loss.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">preds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_extractor</span><span class="o">.</span><span class="n">model</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">temperature</span>
    <span class="n">loss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">CrossEntropyLoss</span><span class="p">(</span><span class="n">reduction</span><span class="o">=</span><span class="s2">&quot;sum&quot;</span><span class="p">)(</span><span class="n">inputs</span><span class="o">=</span><span class="n">preds</span><span class="p">,</span> <span class="n">targets</span><span class="o">=</span><span class="n">labels</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">loss</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h3 id="oodeel.methods.odin.ODIN.input_perturbation" class="doc doc-heading">
<code class="highlight language-python"><span class="n">input_perturbation</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span></code>

<a href="#oodeel.methods.odin.ODIN.input_perturbation" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Apply a small perturbation over inputs to increase their softmax score.
See ODIN paper for more information (section 3):
http://arxiv.org/abs/1706.02690</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>inputs</code></td>
          <td>
                <code><span title="oodeel.types.TensorType">TensorType</span></code>
          </td>
          <td><p>input samples to score</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>TensorType</code></td>          <td>
                <code><span title="oodeel.types.TensorType">TensorType</span></code>
          </td>
          <td><p>Perturbed inputs</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>oodeel/methods/odin.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">input_perturbation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">:</span> <span class="n">TensorType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TensorType</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply a small perturbation over inputs to increase their softmax score.</span>
<span class="sd">    See ODIN paper for more information (section 3):</span>
<span class="sd">    http://arxiv.org/abs/1706.02690</span>

<span class="sd">    Args:</span>
<span class="sd">        inputs (TensorType): input samples to score</span>

<span class="sd">    Returns:</span>
<span class="sd">        TensorType: Perturbed inputs</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">preds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_extractor</span><span class="o">.</span><span class="n">model</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
    <span class="n">outputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">preds</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">gradients</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_temperature_loss</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="p">)</span>
    <span class="n">inputs_p</span> <span class="o">=</span> <span class="n">inputs</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">gradients</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">inputs_p</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>



  </div>

  </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="oodeel.methods.RMDS" class="doc doc-heading">
        <code>RMDS</code>


<a href="#oodeel.methods.RMDS" class="headerlink" title="Permanent link">&para;</a></h2>


  <div class="doc doc-contents ">
      <p class="doc doc-class-bases">
        Bases: <code><a class="autorefs autorefs-internal" title="oodeel.methods.mahalanobis.Mahalanobis" href="#oodeel.methods.Mahalanobis">Mahalanobis</a></code></p>

  
      <p>"A Simple Fix to Mahalanobis Distance for Improving Near-OOD Detection"
https://arxiv.org/abs/2106.09022</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>eps</code></td>
          <td>
                <code>float</code>
          </td>
          <td><p>magnitude for gradient based input perturbation.
Defaults to 0.02.</p></td>
          <td>
                <code>0.002</code>
          </td>
        </tr>
    </tbody>
  </table>


        <details class="quote">
          <summary>Source code in <code>oodeel/methods/rmds.py</code></summary>
          <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 31</span>
<span class="normal"> 32</span>
<span class="normal"> 33</span>
<span class="normal"> 34</span>
<span class="normal"> 35</span>
<span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">RMDS</span><span class="p">(</span><span class="n">Mahalanobis</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &quot;A Simple Fix to Mahalanobis Distance for Improving Near-OOD Detection&quot;</span>
<span class="sd">    https://arxiv.org/abs/2106.09022</span>

<span class="sd">    Args:</span>
<span class="sd">        eps (float): magnitude for gradient based input perturbation.</span>
<span class="sd">            Defaults to 0.02.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eps</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.002</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_fit_to_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fit_dataset</span><span class="p">:</span> <span class="n">DatasetType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructs the per class means and the covariance matrix,</span>
<span class="sd">        as well as the background mean and covariance matrix,</span>
<span class="sd">        from ID data &quot;fit_dataset&quot;.</span>
<span class="sd">        The means and pseudo-inverses of the covariance matrices</span>
<span class="sd">        will be used for RMDS score computation.</span>

<span class="sd">        Args:</span>
<span class="sd">            fit_dataset (Union[TensorType, DatasetType]): input dataset (ID)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># means and pseudo-inverse of the mean convariance matrix from Mahalanobis</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_fit_to_dataset</span><span class="p">(</span><span class="n">fit_dataset</span><span class="p">)</span>

        <span class="c1"># extract features</span>
        <span class="n">features</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_extractor</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">fit_dataset</span><span class="p">)</span>

        <span class="c1"># compute background mu and cov</span>
        <span class="n">_features_bg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">features</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">mu_bg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">_features_bg</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">_zero_f_bg</span> <span class="o">=</span> <span class="n">_features_bg</span> <span class="o">-</span> <span class="n">mu_bg</span>
        <span class="n">cov_bg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">t</span><span class="p">(</span><span class="n">_zero_f_bg</span><span class="p">),</span> <span class="n">_zero_f_bg</span><span class="p">)</span> <span class="o">/</span> <span class="n">_zero_f_bg</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># background mu and pseudo-inverse of the mean covariance matrices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mu_bg</span> <span class="o">=</span> <span class="n">mu_bg</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pinv_cov_bg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">cov_bg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_score_tensor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">:</span> <span class="n">TensorType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes an OOD score for input samples &quot;inputs&quot; based on the RMDS</span>
<span class="sd">        distance with respect to the closest class-conditional Gaussian distribution,</span>
<span class="sd">        and the background distribution.</span>

<span class="sd">        Args:</span>
<span class="sd">            inputs (TensorType): input samples</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple[np.ndarray]: scores, logits</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># input preprocessing (perturbation)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">inputs_p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_perturbation</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">inputs_p</span> <span class="o">=</span> <span class="n">inputs</span>

        <span class="c1"># mahalanobis score on perturbed inputs</span>
        <span class="n">features_p</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_extractor</span><span class="o">.</span><span class="n">predict_tensor</span><span class="p">(</span><span class="n">inputs_p</span><span class="p">)</span>
        <span class="n">features_p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">features_p</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">gaussian_score_p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mahalanobis_score</span><span class="p">(</span><span class="n">features_p</span><span class="p">)</span>

        <span class="c1"># background score on perturbed inputs</span>
        <span class="n">gaussian_score_bg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_score</span><span class="p">(</span><span class="n">features_p</span><span class="p">)</span>

        <span class="c1"># take the highest score for each sample</span>
        <span class="n">gaussian_score_corrected</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">max</span><span class="p">(</span>
            <span class="n">gaussian_score_p</span> <span class="o">-</span> <span class="n">gaussian_score_bg</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">convert_to_numpy</span><span class="p">(</span><span class="n">gaussian_score_corrected</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_background_score</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out_features</span><span class="p">:</span> <span class="n">TensorType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TensorType</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Mahalanobis distance-based background score. For each test sample, it computes</span>
<span class="sd">        the log of the probability densities of some observations (assuming a</span>
<span class="sd">        normal distribution) using the mahalanobis distance with respect to the</span>
<span class="sd">        background distribution.</span>

<span class="sd">        Args:</span>
<span class="sd">            out_features (TensorType): test samples features</span>

<span class="sd">        Returns:</span>
<span class="sd">            TensorType: confidence scores (with respect to the background distribution)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">zero_f</span> <span class="o">=</span> <span class="n">out_features</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mu_bg</span>
        <span class="c1"># gaussian log prob density (mahalanobis)</span>
        <span class="n">log_probs_f</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">zero_f</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pinv_cov_bg</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">t</span><span class="p">(</span><span class="n">zero_f</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="n">gaussian_score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">log_probs_f</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">gaussian_score</span>
</code></pre></div></td></tr></table></div>
        </details>

  

  <div class="doc doc-children">









<div class="doc doc-object doc-function">



<h3 id="oodeel.methods.rmds.RMDS._background_score" class="doc doc-heading">
<code class="highlight language-python"><span class="n">_background_score</span><span class="p">(</span><span class="n">out_features</span><span class="p">)</span></code>

<a href="#oodeel.methods.rmds.RMDS._background_score" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Mahalanobis distance-based background score. For each test sample, it computes
the log of the probability densities of some observations (assuming a
normal distribution) using the mahalanobis distance with respect to the
background distribution.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>out_features</code></td>
          <td>
                <code><span title="oodeel.types.TensorType">TensorType</span></code>
          </td>
          <td><p>test samples features</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>TensorType</code></td>          <td>
                <code><span title="oodeel.types.TensorType">TensorType</span></code>
          </td>
          <td><p>confidence scores (with respect to the background distribution)</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>oodeel/methods/rmds.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">_background_score</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out_features</span><span class="p">:</span> <span class="n">TensorType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TensorType</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mahalanobis distance-based background score. For each test sample, it computes</span>
<span class="sd">    the log of the probability densities of some observations (assuming a</span>
<span class="sd">    normal distribution) using the mahalanobis distance with respect to the</span>
<span class="sd">    background distribution.</span>

<span class="sd">    Args:</span>
<span class="sd">        out_features (TensorType): test samples features</span>

<span class="sd">    Returns:</span>
<span class="sd">        TensorType: confidence scores (with respect to the background distribution)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">zero_f</span> <span class="o">=</span> <span class="n">out_features</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mu_bg</span>
    <span class="c1"># gaussian log prob density (mahalanobis)</span>
    <span class="n">log_probs_f</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">zero_f</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pinv_cov_bg</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">t</span><span class="p">(</span><span class="n">zero_f</span><span class="p">))</span>
    <span class="p">)</span>
    <span class="n">gaussian_score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">log_probs_f</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">gaussian_score</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h3 id="oodeel.methods.rmds.RMDS._fit_to_dataset" class="doc doc-heading">
<code class="highlight language-python"><span class="n">_fit_to_dataset</span><span class="p">(</span><span class="n">fit_dataset</span><span class="p">)</span></code>

<a href="#oodeel.methods.rmds.RMDS._fit_to_dataset" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Constructs the per class means and the covariance matrix,
as well as the background mean and covariance matrix,
from ID data "fit_dataset".
The means and pseudo-inverses of the covariance matrices
will be used for RMDS score computation.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>fit_dataset</code></td>
          <td>
                <code>Union[<span title="oodeel.types.TensorType">TensorType</span>, <span title="oodeel.types.DatasetType">DatasetType</span>]</code>
          </td>
          <td><p>input dataset (ID)</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>oodeel/methods/rmds.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span>
<span class="normal">53</span>
<span class="normal">54</span>
<span class="normal">55</span>
<span class="normal">56</span>
<span class="normal">57</span>
<span class="normal">58</span>
<span class="normal">59</span>
<span class="normal">60</span>
<span class="normal">61</span>
<span class="normal">62</span>
<span class="normal">63</span>
<span class="normal">64</span>
<span class="normal">65</span>
<span class="normal">66</span>
<span class="normal">67</span>
<span class="normal">68</span>
<span class="normal">69</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">_fit_to_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fit_dataset</span><span class="p">:</span> <span class="n">DatasetType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Constructs the per class means and the covariance matrix,</span>
<span class="sd">    as well as the background mean and covariance matrix,</span>
<span class="sd">    from ID data &quot;fit_dataset&quot;.</span>
<span class="sd">    The means and pseudo-inverses of the covariance matrices</span>
<span class="sd">    will be used for RMDS score computation.</span>

<span class="sd">    Args:</span>
<span class="sd">        fit_dataset (Union[TensorType, DatasetType]): input dataset (ID)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># means and pseudo-inverse of the mean convariance matrix from Mahalanobis</span>
    <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_fit_to_dataset</span><span class="p">(</span><span class="n">fit_dataset</span><span class="p">)</span>

    <span class="c1"># extract features</span>
    <span class="n">features</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_extractor</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">fit_dataset</span><span class="p">)</span>

    <span class="c1"># compute background mu and cov</span>
    <span class="n">_features_bg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">features</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">mu_bg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">_features_bg</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">_zero_f_bg</span> <span class="o">=</span> <span class="n">_features_bg</span> <span class="o">-</span> <span class="n">mu_bg</span>
    <span class="n">cov_bg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">t</span><span class="p">(</span><span class="n">_zero_f_bg</span><span class="p">),</span> <span class="n">_zero_f_bg</span><span class="p">)</span> <span class="o">/</span> <span class="n">_zero_f_bg</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># background mu and pseudo-inverse of the mean covariance matrices</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_mu_bg</span> <span class="o">=</span> <span class="n">mu_bg</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_pinv_cov_bg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">cov_bg</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h3 id="oodeel.methods.rmds.RMDS._score_tensor" class="doc doc-heading">
<code class="highlight language-python"><span class="n">_score_tensor</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span></code>

<a href="#oodeel.methods.rmds.RMDS._score_tensor" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Computes an OOD score for input samples "inputs" based on the RMDS
distance with respect to the closest class-conditional Gaussian distribution,
and the background distribution.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>inputs</code></td>
          <td>
                <code><span title="oodeel.types.TensorType">TensorType</span></code>
          </td>
          <td><p>input samples</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code><span title="oodeel.types.Tuple">Tuple</span>[<span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span>]</code>
          </td>
          <td><p>Tuple[np.ndarray]: scores, logits</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>oodeel/methods/rmds.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">_score_tensor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">:</span> <span class="n">TensorType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes an OOD score for input samples &quot;inputs&quot; based on the RMDS</span>
<span class="sd">    distance with respect to the closest class-conditional Gaussian distribution,</span>
<span class="sd">    and the background distribution.</span>

<span class="sd">    Args:</span>
<span class="sd">        inputs (TensorType): input samples</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple[np.ndarray]: scores, logits</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># input preprocessing (perturbation)</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">inputs_p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_perturbation</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">inputs_p</span> <span class="o">=</span> <span class="n">inputs</span>

    <span class="c1"># mahalanobis score on perturbed inputs</span>
    <span class="n">features_p</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_extractor</span><span class="o">.</span><span class="n">predict_tensor</span><span class="p">(</span><span class="n">inputs_p</span><span class="p">)</span>
    <span class="n">features_p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">features_p</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">gaussian_score_p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mahalanobis_score</span><span class="p">(</span><span class="n">features_p</span><span class="p">)</span>

    <span class="c1"># background score on perturbed inputs</span>
    <span class="n">gaussian_score_bg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_background_score</span><span class="p">(</span><span class="n">features_p</span><span class="p">)</span>

    <span class="c1"># take the highest score for each sample</span>
    <span class="n">gaussian_score_corrected</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">max</span><span class="p">(</span>
        <span class="n">gaussian_score_p</span> <span class="o">-</span> <span class="n">gaussian_score_bg</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">convert_to_numpy</span><span class="p">(</span><span class="n">gaussian_score_corrected</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>



  </div>

  </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="oodeel.methods.SHE" class="doc doc-heading">
        <code>SHE</code>


<a href="#oodeel.methods.SHE" class="headerlink" title="Permanent link">&para;</a></h2>


  <div class="doc doc-contents ">
      <p class="doc doc-class-bases">
        Bases: <code><a class="autorefs autorefs-internal" title="oodeel.methods.base.OODBaseDetector" href="#oodeel.methods.base.OODBaseDetector">OODBaseDetector</a></code></p>

  
      <p>"Out-of-Distribution Detection based on In-Distribution Data Patterns Memorization
with Modern Hopfield Energy"
<a href="https://openreview.net/forum?id=KkazG4lgKL">link</a></p>
<p>This method first computes the mean of the internal layer representation of ID data
for each ID class. This mean is seen as the average of the ID activation patterns
as defined in the original paper.
The method then returns the maximum value of the dot product between the internal
layer representation of the input and the average patterns, which is a simplified
version of Hopfield energy as defined in the original paper.</p>
<p>Remarks:
*   An input perturbation is applied in the same way as in Mahalanobis score
*   The original paper only considers the penultimate layer of the neural
network, while we aggregate the results of multiple layers after normalizing by
the dimension of each vector (the activation vector for dense layers, and the
average pooling of the feature map for convolutional layers).</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>eps</code></td>
          <td>
                <code>float</code>
          </td>
          <td><p>magnitude for gradient based input perturbation.
Defaults to 0.0014.</p></td>
          <td>
                <code>0.0014</code>
          </td>
        </tr>
    </tbody>
  </table>


        <details class="quote">
          <summary>Source code in <code>oodeel/methods/she.py</code></summary>
          <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 31</span>
<span class="normal"> 32</span>
<span class="normal"> 33</span>
<span class="normal"> 34</span>
<span class="normal"> 35</span>
<span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">SHE</span><span class="p">(</span><span class="n">OODBaseDetector</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &quot;Out-of-Distribution Detection based on In-Distribution Data Patterns Memorization</span>
<span class="sd">    with Modern Hopfield Energy&quot;</span>
<span class="sd">    [link](https://openreview.net/forum?id=KkazG4lgKL)</span>

<span class="sd">    This method first computes the mean of the internal layer representation of ID data</span>
<span class="sd">    for each ID class. This mean is seen as the average of the ID activation patterns</span>
<span class="sd">    as defined in the original paper.</span>
<span class="sd">    The method then returns the maximum value of the dot product between the internal</span>
<span class="sd">    layer representation of the input and the average patterns, which is a simplified</span>
<span class="sd">    version of Hopfield energy as defined in the original paper.</span>

<span class="sd">    Remarks:</span>
<span class="sd">    *   An input perturbation is applied in the same way as in Mahalanobis score</span>
<span class="sd">    *   The original paper only considers the penultimate layer of the neural</span>
<span class="sd">    network, while we aggregate the results of multiple layers after normalizing by</span>
<span class="sd">    the dimension of each vector (the activation vector for dense layers, and the</span>
<span class="sd">    average pooling of the feature map for convolutional layers).</span>

<span class="sd">    Args:</span>
<span class="sd">        eps (float): magnitude for gradient based input perturbation.</span>
<span class="sd">            Defaults to 0.0014.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">eps</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0014</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eps</span> <span class="o">=</span> <span class="n">eps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">postproc_fns</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_postproc_feature_maps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">feature_map</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">feature_map</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">feature_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">avg_pool_2d</span><span class="p">(</span><span class="n">feature_map</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">feature_map</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_fit_to_dataset</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">fit_dataset</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">TensorType</span><span class="p">,</span> <span class="n">DatasetType</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the means of the input dataset in the activation space of the selected</span>
<span class="sd">        layers. The means are computed for each class in the dataset.</span>

<span class="sd">        Args:</span>
<span class="sd">            fit_dataset (Union[TensorType, DatasetType]): input dataset (ID) to</span>
<span class="sd">                construct the index with.</span>
<span class="sd">            ood_dataset (Union[TensorType, DatasetType]): OOD dataset to tune the</span>
<span class="sd">                aggregation coefficients.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">postproc_fns</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_postproc_feature_maps</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">feature_extractor</span><span class="o">.</span><span class="n">feature_layers_id</span><span class="p">))</span>
        <span class="p">]</span>

        <span class="n">features</span><span class="p">,</span> <span class="n">infos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_extractor</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span>
            <span class="n">fit_dataset</span><span class="p">,</span> <span class="n">postproc_fns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">postproc_fns</span>
        <span class="p">)</span>

        <span class="n">labels</span> <span class="o">=</span> <span class="n">infos</span><span class="p">[</span><span class="s2">&quot;labels&quot;</span><span class="p">]</span>
        <span class="n">preds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">infos</span><span class="p">[</span><span class="s2">&quot;logits&quot;</span><span class="p">],</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">preds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">convert_to_numpy</span><span class="p">(</span><span class="n">preds</span><span class="p">)</span>

        <span class="c1"># unique sorted classes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_classes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">convert_to_numpy</span><span class="p">(</span><span class="n">labels</span><span class="p">)))</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">convert_to_numpy</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_mus</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">feature</span> <span class="ow">in</span> <span class="n">features</span><span class="p">:</span>
            <span class="n">mus_f</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="k">for</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_classes</span><span class="p">:</span>
                <span class="n">indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">preds</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span>
                <span class="n">_features_cls</span> <span class="o">=</span> <span class="n">feature</span><span class="p">[</span><span class="n">indexes</span><span class="p">]</span>
                <span class="n">mus_f</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">_features_cls</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mus</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="n">mus_f</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">_score_tensor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">:</span> <span class="n">TensorType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes an OOD score for input samples &quot;inputs&quot; based on</span>
<span class="sd">        the aggregation of neural mean discrepancies from different layers.</span>

<span class="sd">        Args:</span>
<span class="sd">            inputs: input samples to score</span>

<span class="sd">        Returns:</span>
<span class="sd">            scores</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">inputs_p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_perturbation</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
        <span class="n">features</span><span class="p">,</span> <span class="n">logits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_extractor</span><span class="o">.</span><span class="n">predict_tensor</span><span class="p">(</span>
            <span class="n">inputs_p</span><span class="p">,</span> <span class="n">postproc_fns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">postproc_fns</span>
        <span class="p">)</span>

        <span class="n">scores</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_she_output</span><span class="p">(</span><span class="n">features</span><span class="p">)</span>

        <span class="k">return</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">convert_to_numpy</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_she_output</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">features</span><span class="p">):</span>
        <span class="n">scores</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">feature</span><span class="p">,</span> <span class="n">mus_f</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">features</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mus</span><span class="p">):</span>
            <span class="n">she</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">feature</span><span class="p">),</span> <span class="n">mus_f</span><span class="p">)</span> <span class="o">/</span> <span class="n">feature</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">she</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">she</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">scores</span> <span class="o">=</span> <span class="n">she</span> <span class="k">if</span> <span class="n">scores</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">she</span> <span class="o">+</span> <span class="n">scores</span>
        <span class="k">return</span> <span class="n">scores</span>

    <span class="k">def</span> <span class="nf">_input_perturbation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">:</span> <span class="n">TensorType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TensorType</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply small perturbation on inputs to make the in- and out- distribution</span>
<span class="sd">        samples more separable.</span>

<span class="sd">        Args:</span>
<span class="sd">            inputs (TensorType): input samples</span>

<span class="sd">        Returns:</span>
<span class="sd">            TensorType: Perturbed inputs</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">__loss_fn</span><span class="p">(</span><span class="n">inputs</span><span class="p">:</span> <span class="n">TensorType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TensorType</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Loss function for the input perturbation.</span>

<span class="sd">            Args:</span>
<span class="sd">                inputs (TensorType): input samples</span>

<span class="sd">            Returns:</span>
<span class="sd">                TensorType: loss value</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="c1"># extract features</span>
            <span class="n">out_features</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_extractor</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span>
                <span class="n">inputs</span><span class="p">,</span> <span class="n">detach</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">postproc_fns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">postproc_fns</span>
            <span class="p">)</span>
            <span class="c1"># get mahalanobis score for the class maximizing it</span>
            <span class="n">she_score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_she_output</span><span class="p">(</span><span class="n">out_features</span><span class="p">)</span>
            <span class="n">log_probs_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">she_score</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">log_probs_f</span><span class="p">)</span>

        <span class="c1"># compute gradient</span>
        <span class="n">gradient</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">__loss_fn</span><span class="p">,</span> <span class="n">inputs</span><span class="p">)</span>
        <span class="n">gradient</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">gradient</span><span class="p">)</span>

        <span class="n">inputs_p</span> <span class="o">=</span> <span class="n">inputs</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span> <span class="o">*</span> <span class="n">gradient</span>
        <span class="k">return</span> <span class="n">inputs_p</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">requires_to_fit_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Whether an OOD detector needs a `fit_dataset` argument in the fit function.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if `fit_dataset` is required else False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">requires_internal_features</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Whether an OOD detector acts on internal model features.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if the detector perform computations on an intermediate layer</span>
<span class="sd">            else False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">True</span>
</code></pre></div></td></tr></table></div>
        </details>

  

  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h3 id="oodeel.methods.she.SHE.requires_internal_features" class="doc doc-heading">
<code class="highlight language-python"><span class="n">requires_internal_features</span><span class="p">:</span> <span class="nb">bool</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

<a href="#oodeel.methods.she.SHE.requires_internal_features" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Whether an OOD detector acts on internal model features.</p>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>bool</code></td>          <td>
                <code>bool</code>
          </td>
          <td><p>True if the detector perform computations on an intermediate layer</p></td>
        </tr>
        <tr>
<td></td>          <td>
                <code>bool</code>
          </td>
          <td><p>else False.</p></td>
        </tr>
    </tbody>
  </table>
  </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="oodeel.methods.she.SHE.requires_to_fit_dataset" class="doc doc-heading">
<code class="highlight language-python"><span class="n">requires_to_fit_dataset</span><span class="p">:</span> <span class="nb">bool</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

<a href="#oodeel.methods.she.SHE.requires_to_fit_dataset" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Whether an OOD detector needs a <code>fit_dataset</code> argument in the fit function.</p>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>bool</code></td>          <td>
                <code>bool</code>
          </td>
          <td><p>True if <code>fit_dataset</code> is required else False.</p></td>
        </tr>
    </tbody>
  </table>
  </div>

</div>



<div class="doc doc-object doc-function">



<h3 id="oodeel.methods.she.SHE._fit_to_dataset" class="doc doc-heading">
<code class="highlight language-python"><span class="n">_fit_to_dataset</span><span class="p">(</span><span class="n">fit_dataset</span><span class="p">)</span></code>

<a href="#oodeel.methods.she.SHE._fit_to_dataset" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Compute the means of the input dataset in the activation space of the selected
layers. The means are computed for each class in the dataset.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>fit_dataset</code></td>
          <td>
                <code><span title="oodeel.types.Union">Union</span>[<span title="oodeel.types.TensorType">TensorType</span>, <span title="oodeel.types.DatasetType">DatasetType</span>]</code>
          </td>
          <td><p>input dataset (ID) to
construct the index with.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>ood_dataset</code></td>
          <td>
                <code><span title="oodeel.types.Union">Union</span>[<span title="oodeel.types.TensorType">TensorType</span>, <span title="oodeel.types.DatasetType">DatasetType</span>]</code>
          </td>
          <td><p>OOD dataset to tune the
aggregation coefficients.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>oodeel/methods/she.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">_fit_to_dataset</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">fit_dataset</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">TensorType</span><span class="p">,</span> <span class="n">DatasetType</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the means of the input dataset in the activation space of the selected</span>
<span class="sd">    layers. The means are computed for each class in the dataset.</span>

<span class="sd">    Args:</span>
<span class="sd">        fit_dataset (Union[TensorType, DatasetType]): input dataset (ID) to</span>
<span class="sd">            construct the index with.</span>
<span class="sd">        ood_dataset (Union[TensorType, DatasetType]): OOD dataset to tune the</span>
<span class="sd">            aggregation coefficients.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">postproc_fns</span> <span class="o">=</span> <span class="p">[</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_postproc_feature_maps</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">feature_extractor</span><span class="o">.</span><span class="n">feature_layers_id</span><span class="p">))</span>
    <span class="p">]</span>

    <span class="n">features</span><span class="p">,</span> <span class="n">infos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_extractor</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span>
        <span class="n">fit_dataset</span><span class="p">,</span> <span class="n">postproc_fns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">postproc_fns</span>
    <span class="p">)</span>

    <span class="n">labels</span> <span class="o">=</span> <span class="n">infos</span><span class="p">[</span><span class="s2">&quot;labels&quot;</span><span class="p">]</span>
    <span class="n">preds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">infos</span><span class="p">[</span><span class="s2">&quot;logits&quot;</span><span class="p">],</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">preds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">convert_to_numpy</span><span class="p">(</span><span class="n">preds</span><span class="p">)</span>

    <span class="c1"># unique sorted classes</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_classes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">convert_to_numpy</span><span class="p">(</span><span class="n">labels</span><span class="p">)))</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">convert_to_numpy</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">_mus</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">feature</span> <span class="ow">in</span> <span class="n">features</span><span class="p">:</span>
        <span class="n">mus_f</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_classes</span><span class="p">:</span>
            <span class="n">indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">preds</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span>
            <span class="n">_features_cls</span> <span class="o">=</span> <span class="n">feature</span><span class="p">[</span><span class="n">indexes</span><span class="p">]</span>
            <span class="n">mus_f</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">_features_cls</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mus</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="n">mus_f</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h3 id="oodeel.methods.she.SHE._input_perturbation" class="doc doc-heading">
<code class="highlight language-python"><span class="n">_input_perturbation</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span></code>

<a href="#oodeel.methods.she.SHE._input_perturbation" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Apply small perturbation on inputs to make the in- and out- distribution
samples more separable.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>inputs</code></td>
          <td>
                <code><span title="oodeel.types.TensorType">TensorType</span></code>
          </td>
          <td><p>input samples</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>TensorType</code></td>          <td>
                <code><span title="oodeel.types.TensorType">TensorType</span></code>
          </td>
          <td><p>Perturbed inputs</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>oodeel/methods/she.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">_input_perturbation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">:</span> <span class="n">TensorType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TensorType</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply small perturbation on inputs to make the in- and out- distribution</span>
<span class="sd">    samples more separable.</span>

<span class="sd">    Args:</span>
<span class="sd">        inputs (TensorType): input samples</span>

<span class="sd">    Returns:</span>
<span class="sd">        TensorType: Perturbed inputs</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__loss_fn</span><span class="p">(</span><span class="n">inputs</span><span class="p">:</span> <span class="n">TensorType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TensorType</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loss function for the input perturbation.</span>

<span class="sd">        Args:</span>
<span class="sd">            inputs (TensorType): input samples</span>

<span class="sd">        Returns:</span>
<span class="sd">            TensorType: loss value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># extract features</span>
        <span class="n">out_features</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_extractor</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span>
            <span class="n">inputs</span><span class="p">,</span> <span class="n">detach</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">postproc_fns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">postproc_fns</span>
        <span class="p">)</span>
        <span class="c1"># get mahalanobis score for the class maximizing it</span>
        <span class="n">she_score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_she_output</span><span class="p">(</span><span class="n">out_features</span><span class="p">)</span>
        <span class="n">log_probs_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">she_score</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">log_probs_f</span><span class="p">)</span>

    <span class="c1"># compute gradient</span>
    <span class="n">gradient</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">__loss_fn</span><span class="p">,</span> <span class="n">inputs</span><span class="p">)</span>
    <span class="n">gradient</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">gradient</span><span class="p">)</span>

    <span class="n">inputs_p</span> <span class="o">=</span> <span class="n">inputs</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span> <span class="o">*</span> <span class="n">gradient</span>
    <span class="k">return</span> <span class="n">inputs_p</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h3 id="oodeel.methods.she.SHE._score_tensor" class="doc doc-heading">
<code class="highlight language-python"><span class="n">_score_tensor</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span></code>

<a href="#oodeel.methods.she.SHE._score_tensor" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Computes an OOD score for input samples "inputs" based on
the aggregation of neural mean discrepancies from different layers.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>inputs</code></td>
          <td>
                <code><span title="oodeel.types.TensorType">TensorType</span></code>
          </td>
          <td><p>input samples to score</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>scores</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>oodeel/methods/she.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">_score_tensor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">:</span> <span class="n">TensorType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes an OOD score for input samples &quot;inputs&quot; based on</span>
<span class="sd">    the aggregation of neural mean discrepancies from different layers.</span>

<span class="sd">    Args:</span>
<span class="sd">        inputs: input samples to score</span>

<span class="sd">    Returns:</span>
<span class="sd">        scores</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">inputs_p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_perturbation</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
    <span class="n">features</span><span class="p">,</span> <span class="n">logits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_extractor</span><span class="o">.</span><span class="n">predict_tensor</span><span class="p">(</span>
        <span class="n">inputs_p</span><span class="p">,</span> <span class="n">postproc_fns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">postproc_fns</span>
    <span class="p">)</span>

    <span class="n">scores</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_she_output</span><span class="p">(</span><span class="n">features</span><span class="p">)</span>

    <span class="k">return</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">convert_to_numpy</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>



  </div>

  </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="oodeel.methods.VIM" class="doc doc-heading">
        <code>VIM</code>


<a href="#oodeel.methods.VIM" class="headerlink" title="Permanent link">&para;</a></h2>


  <div class="doc doc-contents ">
      <p class="doc doc-class-bases">
        Bases: <code><a class="autorefs autorefs-internal" title="oodeel.methods.base.OODBaseDetector" href="#oodeel.methods.base.OODBaseDetector">OODBaseDetector</a></code></p>

  
      <p>Compute the Virtual Matching Logit (VIM) score.
https://arxiv.org/abs/2203.10807</p>
<p>This score combines the energy score with a PCA residual score.</p>
<p>The energy score is the logarithm of the sum of exponential of logits.
The PCA residual score is based on the projection on residual dimensions for
principal component analysis.
    Residual dimensions are the eigenvectors corresponding to the least eignevalues
    (least variance).
    Intuitively, this score method assumes that feature representations of ID data
    occupy a low dimensional affine subspace $P+c$ of the feature space.
    Specifically, the projection of ID data translated by $-c$ on the
    orthognoal complement $P^{\perp}$ is expected to have small norm.
    It allows to detect points whose feature representation lie far from the
    identified affine subspace, namely those points $x$ such that the
    projection on $P^{\perp}$ of $x-c$ has large norm.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>princ_dims</code></td>
          <td>
                <code><span title="oodeel.types.Union">Union</span>[int, float]</code>
          </td>
          <td><p>number of principal dimensions of in
distribution features to consider. If an int, must be less than the
dimension of the feature space.
If a float, it must be in [0,1), it represents the ratio of
explained variance to consider to determine the number of principal
components. Defaults to 0.99.</p></td>
          <td>
                <code>0.99</code>
          </td>
        </tr>
        <tr>
          <td><code>pca_origin</code></td>
          <td>
                <code>str</code>
          </td>
          <td><p>either "pseudo" for using $W^{-1}b$ where $W^{-1}$ is
the pseudo inverse of the final linear layer applied to bias term
(as in the VIM paper), or "center" for using the mean of the data in
feature space. Defaults to "pseudo".</p></td>
          <td>
                <code>&#39;pseudo&#39;</code>
          </td>
        </tr>
    </tbody>
  </table>


        <details class="quote">
          <summary>Source code in <code>oodeel/methods/vim.py</code></summary>
          <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 34</span>
<span class="normal"> 35</span>
<span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">VIM</span><span class="p">(</span><span class="n">OODBaseDetector</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the Virtual Matching Logit (VIM) score.</span>
<span class="sd">    https://arxiv.org/abs/2203.10807</span>

<span class="sd">    This score combines the energy score with a PCA residual score.</span>

<span class="sd">    The energy score is the logarithm of the sum of exponential of logits.</span>
<span class="sd">    The PCA residual score is based on the projection on residual dimensions for</span>
<span class="sd">    principal component analysis.</span>
<span class="sd">        Residual dimensions are the eigenvectors corresponding to the least eignevalues</span>
<span class="sd">        (least variance).</span>
<span class="sd">        Intuitively, this score method assumes that feature representations of ID data</span>
<span class="sd">        occupy a low dimensional affine subspace $P+c$ of the feature space.</span>
<span class="sd">        Specifically, the projection of ID data translated by $-c$ on the</span>
<span class="sd">        orthognoal complement $P^{\\perp}$ is expected to have small norm.</span>
<span class="sd">        It allows to detect points whose feature representation lie far from the</span>
<span class="sd">        identified affine subspace, namely those points $x$ such that the</span>
<span class="sd">        projection on $P^{\\perp}$ of $x-c$ has large norm.</span>

<span class="sd">    Args:</span>
<span class="sd">        princ_dims (Union[int, float]): number of principal dimensions of in</span>
<span class="sd">            distribution features to consider. If an int, must be less than the</span>
<span class="sd">            dimension of the feature space.</span>
<span class="sd">            If a float, it must be in [0,1), it represents the ratio of</span>
<span class="sd">            explained variance to consider to determine the number of principal</span>
<span class="sd">            components. Defaults to 0.99.</span>
<span class="sd">        pca_origin (str): either &quot;pseudo&quot; for using $W^{-1}b$ where $W^{-1}$ is</span>
<span class="sd">            the pseudo inverse of the final linear layer applied to bias term</span>
<span class="sd">            (as in the VIM paper), or &quot;center&quot; for using the mean of the data in</span>
<span class="sd">            feature space. Defaults to &quot;pseudo&quot;.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">princ_dims</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.99</span><span class="p">,</span>
        <span class="n">pca_origin</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;pseudo&quot;</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_princ_dim</span> <span class="o">=</span> <span class="n">princ_dims</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pca_origin</span> <span class="o">=</span> <span class="n">pca_origin</span>

    <span class="k">def</span> <span class="nf">_fit_to_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fit_dataset</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">TensorType</span><span class="p">,</span> <span class="n">DatasetType</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes principal components of feature representations and store the residual</span>
<span class="sd">        eigenvectors.</span>
<span class="sd">        Computes a scaling factor constant :math:&#39;\alpha&#39; such that the average scaled</span>
<span class="sd">        residual score (on train) is equal to the average maximum logit score (MLS)</span>
<span class="sd">        score.</span>

<span class="sd">        Args:</span>
<span class="sd">            fit_dataset: input dataset (ID) to construct the index with.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># extract features from fit dataset</span>
        <span class="n">all_features_train</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_extractor</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">fit_dataset</span><span class="p">)</span>
        <span class="n">features_train</span> <span class="o">=</span> <span class="n">all_features_train</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">logits_train</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s2">&quot;logits&quot;</span><span class="p">]</span>
        <span class="n">features_train</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">features_train</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">feature_dim</span> <span class="o">=</span> <span class="n">features_train</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">logits_train</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">convert_to_numpy</span><span class="p">(</span><span class="n">logits_train</span><span class="p">)</span>

        <span class="c1"># get distribution center for pca projection</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pca_origin</span> <span class="o">==</span> <span class="s2">&quot;center&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">center</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">features_train</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">pca_origin</span> <span class="o">==</span> <span class="s2">&quot;pseudo&quot;</span><span class="p">:</span>
            <span class="c1"># W, b = self.feature_extractor.get_weights(</span>
            <span class="c1">#    self.feature_extractor.feature_layers_id[0]</span>
            <span class="c1"># )</span>
            <span class="n">W</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_extractor</span><span class="o">.</span><span class="n">get_weights</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">W</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">W</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">_W</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">t</span><span class="p">(</span><span class="n">W</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">backend</span> <span class="o">==</span> <span class="s2">&quot;tensorflow&quot;</span> <span class="k">else</span> <span class="n">W</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">center</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">_W</span><span class="p">),</span> <span class="n">b</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s1">&#39;only &quot;center&quot; and &quot;pseudo&quot; are available for argument &quot;pca_origin&quot;&#39;</span>
            <span class="p">)</span>

        <span class="c1"># compute eigvalues and eigvectors of empirical covariance matrix</span>
        <span class="n">centered_features</span> <span class="o">=</span> <span class="n">features_train</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span>
        <span class="n">emp_cov</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">t</span><span class="p">(</span><span class="n">centered_features</span><span class="p">),</span> <span class="n">centered_features</span><span class="p">)</span>
            <span class="o">/</span> <span class="n">centered_features</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">eig_vals</span><span class="p">,</span> <span class="n">eigen_vectors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">emp_cov</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eig_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">convert_to_numpy</span><span class="p">(</span><span class="n">eig_vals</span><span class="p">)</span>

        <span class="c1"># get number of residual dims for pca projection</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_princ_dim</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_princ_dim</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_dim</span><span class="p">,</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;if &#39;princ_dims&#39;(=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_princ_dim</span><span class="si">}</span><span class="s2">) is an int, it must be less than &quot;</span>
                <span class="s2">&quot;feature space dimension =</span><span class="si">{self.feature_dim}</span><span class="s2">)&quot;</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">res_dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_dim</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_princ_dim</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_princ_dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_princ_dim</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_princ_dim</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="mi">0</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_princ_dim</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_princ_dim</span> <span class="o">&lt;</span> <span class="mi">1</span>
            <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;if &#39;princ_dims&#39;(=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_princ_dim</span><span class="si">}</span><span class="s2">) is a float, it must be in [0,1)&quot;</span>
            <span class="n">explained_variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eig_vals</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eig_vals</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_princ_dim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">explained_variance</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_princ_dim</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">res_dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_dim</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_princ_dim</span>

        <span class="c1"># projector on residual space</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">res</span> <span class="o">=</span> <span class="n">eigen_vectors</span><span class="p">[:,</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">res_dim</span><span class="p">]</span>  <span class="c1"># asc. order with eigh</span>

        <span class="c1"># compute residual score on training data</span>
        <span class="n">train_residual_scores</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_residual_score_tensor</span><span class="p">(</span><span class="n">features_train</span><span class="p">)</span>
        <span class="c1"># compute MLS on training data</span>
        <span class="n">train_mls_scores</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">logits_train</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># compute scaling factor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">train_mls_scores</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">train_residual_scores</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_compute_residual_score_tensor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">features</span><span class="p">:</span> <span class="n">TensorType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the norm of the residual projection in the feature space.</span>

<span class="sd">        Args:</span>
<span class="sd">            features: input samples to score</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: scores</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res_coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">features</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">res</span><span class="p">)</span>
        <span class="c1"># taking the norm of the coordinates, which amounts to the norm of</span>
        <span class="c1"># the projection since the eigenvectors form an orthornomal basis</span>
        <span class="n">res_norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">res_coordinates</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">convert_to_numpy</span><span class="p">(</span><span class="n">res_norm</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_score_tensor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">:</span> <span class="n">TensorType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the VIM score for input samples &quot;inputs&quot; as the sum of the energy</span>
<span class="sd">        score and a scaled (PCA) residual norm in the feature space.</span>

<span class="sd">        Args:</span>
<span class="sd">            inputs: input samples to score</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple[np.ndarray]: scores, logits</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># extract features</span>
        <span class="n">features</span><span class="p">,</span> <span class="n">logits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_extractor</span><span class="o">.</span><span class="n">predict_tensor</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
        <span class="n">features</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">features</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="c1"># vim score</span>
        <span class="n">res_scores</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_residual_score_tensor</span><span class="p">(</span><span class="n">features</span><span class="p">)</span>
        <span class="n">logits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">convert_to_numpy</span><span class="p">(</span><span class="n">logits</span><span class="p">)</span>
        <span class="n">energy_scores</span> <span class="o">=</span> <span class="n">logsumexp</span><span class="p">(</span><span class="n">logits</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">scores</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">res_scores</span> <span class="o">+</span> <span class="n">energy_scores</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">plot_spectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot cumulated explained variance wrt the number of principal dimensions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cumul_explained_variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eig_vals</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cumul_explained_variance</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">cumul_explained_variance</span><span class="p">))</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span>
            <span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_princ_dim</span><span class="p">,</span>
            <span class="n">color</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">,</span>
            <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;--&quot;</span><span class="p">,</span>
            <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;princ_dims = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_princ_dim</span><span class="si">}</span><span class="s2"> &quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Residual explained variance&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Number of principal dimensions&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">requires_to_fit_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Whether an OOD detector needs a `fit_dataset` argument in the fit function.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if `fit_dataset` is required else False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">requires_internal_features</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Whether an OOD detector acts on internal model features.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if the detector perform computations on an intermediate layer</span>
<span class="sd">            else False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">True</span>
</code></pre></div></td></tr></table></div>
        </details>

  

  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h3 id="oodeel.methods.vim.VIM.requires_internal_features" class="doc doc-heading">
<code class="highlight language-python"><span class="n">requires_internal_features</span><span class="p">:</span> <span class="nb">bool</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

<a href="#oodeel.methods.vim.VIM.requires_internal_features" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Whether an OOD detector acts on internal model features.</p>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>bool</code></td>          <td>
                <code>bool</code>
          </td>
          <td><p>True if the detector perform computations on an intermediate layer</p></td>
        </tr>
        <tr>
<td></td>          <td>
                <code>bool</code>
          </td>
          <td><p>else False.</p></td>
        </tr>
    </tbody>
  </table>
  </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="oodeel.methods.vim.VIM.requires_to_fit_dataset" class="doc doc-heading">
<code class="highlight language-python"><span class="n">requires_to_fit_dataset</span><span class="p">:</span> <span class="nb">bool</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

<a href="#oodeel.methods.vim.VIM.requires_to_fit_dataset" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Whether an OOD detector needs a <code>fit_dataset</code> argument in the fit function.</p>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>bool</code></td>          <td>
                <code>bool</code>
          </td>
          <td><p>True if <code>fit_dataset</code> is required else False.</p></td>
        </tr>
    </tbody>
  </table>
  </div>

</div>



<div class="doc doc-object doc-function">



<h3 id="oodeel.methods.vim.VIM._compute_residual_score_tensor" class="doc doc-heading">
<code class="highlight language-python"><span class="n">_compute_residual_score_tensor</span><span class="p">(</span><span class="n">features</span><span class="p">)</span></code>

<a href="#oodeel.methods.vim.VIM._compute_residual_score_tensor" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Computes the norm of the residual projection in the feature space.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>features</code></td>
          <td>
                <code><span title="oodeel.types.TensorType">TensorType</span></code>
          </td>
          <td><p>input samples to score</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>np.ndarray: scores</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>oodeel/methods/vim.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">_compute_residual_score_tensor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">features</span><span class="p">:</span> <span class="n">TensorType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the norm of the residual projection in the feature space.</span>

<span class="sd">    Args:</span>
<span class="sd">        features: input samples to score</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: scores</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">res_coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">features</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">res</span><span class="p">)</span>
    <span class="c1"># taking the norm of the coordinates, which amounts to the norm of</span>
    <span class="c1"># the projection since the eigenvectors form an orthornomal basis</span>
    <span class="n">res_norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">res_coordinates</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">convert_to_numpy</span><span class="p">(</span><span class="n">res_norm</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h3 id="oodeel.methods.vim.VIM._fit_to_dataset" class="doc doc-heading">
<code class="highlight language-python"><span class="n">_fit_to_dataset</span><span class="p">(</span><span class="n">fit_dataset</span><span class="p">)</span></code>

<a href="#oodeel.methods.vim.VIM._fit_to_dataset" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Computes principal components of feature representations and store the residual
eigenvectors.
Computes a scaling factor constant :math:'lpha' such that the average scaled
residual score (on train) is equal to the average maximum logit score (MLS)
score.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>fit_dataset</code></td>
          <td>
                <code><span title="oodeel.types.Union">Union</span>[<span title="oodeel.types.TensorType">TensorType</span>, <span title="oodeel.types.DatasetType">DatasetType</span>]</code>
          </td>
          <td><p>input dataset (ID) to construct the index with.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>oodeel/methods/vim.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">_fit_to_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fit_dataset</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">TensorType</span><span class="p">,</span> <span class="n">DatasetType</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes principal components of feature representations and store the residual</span>
<span class="sd">    eigenvectors.</span>
<span class="sd">    Computes a scaling factor constant :math:&#39;\alpha&#39; such that the average scaled</span>
<span class="sd">    residual score (on train) is equal to the average maximum logit score (MLS)</span>
<span class="sd">    score.</span>

<span class="sd">    Args:</span>
<span class="sd">        fit_dataset: input dataset (ID) to construct the index with.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># extract features from fit dataset</span>
    <span class="n">all_features_train</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_extractor</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">fit_dataset</span><span class="p">)</span>
    <span class="n">features_train</span> <span class="o">=</span> <span class="n">all_features_train</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">logits_train</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s2">&quot;logits&quot;</span><span class="p">]</span>
    <span class="n">features_train</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">features_train</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">feature_dim</span> <span class="o">=</span> <span class="n">features_train</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">logits_train</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">convert_to_numpy</span><span class="p">(</span><span class="n">logits_train</span><span class="p">)</span>

    <span class="c1"># get distribution center for pca projection</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pca_origin</span> <span class="o">==</span> <span class="s2">&quot;center&quot;</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">center</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">features_train</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">pca_origin</span> <span class="o">==</span> <span class="s2">&quot;pseudo&quot;</span><span class="p">:</span>
        <span class="c1"># W, b = self.feature_extractor.get_weights(</span>
        <span class="c1">#    self.feature_extractor.feature_layers_id[0]</span>
        <span class="c1"># )</span>
        <span class="n">W</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_extractor</span><span class="o">.</span><span class="n">get_weights</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">W</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">W</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">_W</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">t</span><span class="p">(</span><span class="n">W</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">backend</span> <span class="o">==</span> <span class="s2">&quot;tensorflow&quot;</span> <span class="k">else</span> <span class="n">W</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">center</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">_W</span><span class="p">),</span> <span class="n">b</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s1">&#39;only &quot;center&quot; and &quot;pseudo&quot; are available for argument &quot;pca_origin&quot;&#39;</span>
        <span class="p">)</span>

    <span class="c1"># compute eigvalues and eigvectors of empirical covariance matrix</span>
    <span class="n">centered_features</span> <span class="o">=</span> <span class="n">features_train</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span>
    <span class="n">emp_cov</span> <span class="o">=</span> <span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">t</span><span class="p">(</span><span class="n">centered_features</span><span class="p">),</span> <span class="n">centered_features</span><span class="p">)</span>
        <span class="o">/</span> <span class="n">centered_features</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">eig_vals</span><span class="p">,</span> <span class="n">eigen_vectors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">emp_cov</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">eig_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">convert_to_numpy</span><span class="p">(</span><span class="n">eig_vals</span><span class="p">)</span>

    <span class="c1"># get number of residual dims for pca projection</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_princ_dim</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_princ_dim</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_dim</span><span class="p">,</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;if &#39;princ_dims&#39;(=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_princ_dim</span><span class="si">}</span><span class="s2">) is an int, it must be less than &quot;</span>
            <span class="s2">&quot;feature space dimension =</span><span class="si">{self.feature_dim}</span><span class="s2">)&quot;</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">res_dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_dim</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_princ_dim</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_princ_dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_princ_dim</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_princ_dim</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="mi">0</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_princ_dim</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_princ_dim</span> <span class="o">&lt;</span> <span class="mi">1</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;if &#39;princ_dims&#39;(=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_princ_dim</span><span class="si">}</span><span class="s2">) is a float, it must be in [0,1)&quot;</span>
        <span class="n">explained_variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eig_vals</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eig_vals</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_princ_dim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">explained_variance</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_princ_dim</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">res_dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_dim</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_princ_dim</span>

    <span class="c1"># projector on residual space</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">res</span> <span class="o">=</span> <span class="n">eigen_vectors</span><span class="p">[:,</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">res_dim</span><span class="p">]</span>  <span class="c1"># asc. order with eigh</span>

    <span class="c1"># compute residual score on training data</span>
    <span class="n">train_residual_scores</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_residual_score_tensor</span><span class="p">(</span><span class="n">features_train</span><span class="p">)</span>
    <span class="c1"># compute MLS on training data</span>
    <span class="n">train_mls_scores</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">logits_train</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># compute scaling factor</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">train_mls_scores</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">train_residual_scores</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h3 id="oodeel.methods.vim.VIM._score_tensor" class="doc doc-heading">
<code class="highlight language-python"><span class="n">_score_tensor</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span></code>

<a href="#oodeel.methods.vim.VIM._score_tensor" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Computes the VIM score for input samples "inputs" as the sum of the energy
score and a scaled (PCA) residual norm in the feature space.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>inputs</code></td>
          <td>
                <code><span title="oodeel.types.TensorType">TensorType</span></code>
          </td>
          <td><p>input samples to score</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code><span title="oodeel.types.Tuple">Tuple</span>[<span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span>]</code>
          </td>
          <td><p>Tuple[np.ndarray]: scores, logits</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>oodeel/methods/vim.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">_score_tensor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">:</span> <span class="n">TensorType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the VIM score for input samples &quot;inputs&quot; as the sum of the energy</span>
<span class="sd">    score and a scaled (PCA) residual norm in the feature space.</span>

<span class="sd">    Args:</span>
<span class="sd">        inputs: input samples to score</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple[np.ndarray]: scores, logits</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># extract features</span>
    <span class="n">features</span><span class="p">,</span> <span class="n">logits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_extractor</span><span class="o">.</span><span class="n">predict_tensor</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
    <span class="n">features</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">features</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="c1"># vim score</span>
    <span class="n">res_scores</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_residual_score_tensor</span><span class="p">(</span><span class="n">features</span><span class="p">)</span>
    <span class="n">logits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">convert_to_numpy</span><span class="p">(</span><span class="n">logits</span><span class="p">)</span>
    <span class="n">energy_scores</span> <span class="o">=</span> <span class="n">logsumexp</span><span class="p">(</span><span class="n">logits</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">scores</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">res_scores</span> <span class="o">+</span> <span class="n">energy_scores</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h3 id="oodeel.methods.vim.VIM.plot_spectrum" class="doc doc-heading">
<code class="highlight language-python"><span class="n">plot_spectrum</span><span class="p">()</span></code>

<a href="#oodeel.methods.vim.VIM.plot_spectrum" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Plot cumulated explained variance wrt the number of principal dimensions.</p>

      <details class="quote">
        <summary>Source code in <code>oodeel/methods/vim.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">plot_spectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plot cumulated explained variance wrt the number of principal dimensions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cumul_explained_variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eig_vals</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cumul_explained_variance</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">cumul_explained_variance</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span>
        <span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_princ_dim</span><span class="p">,</span>
        <span class="n">color</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">,</span>
        <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;--&quot;</span><span class="p">,</span>
        <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;princ_dims = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_princ_dim</span><span class="si">}</span><span class="s2"> &quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Residual explained variance&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Number of principal dimensions&quot;</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>



  </div>

  </div>

</div>




  </div>

  </div>

</div>





                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": "../..", "features": [], "search": "../../assets/javascripts/workers/search.208ed371.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": {"provider": "mike"}}</script>
    
    
      <script src="../../assets/javascripts/bundle.fac441b0.min.js"></script>
      
        <script src="../../js/custom.js"></script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.7/katex.min.js"></script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.7/contrib/auto-render.min.js"></script>
      
    
  </body>
</html>